<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://hoonably.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://hoonably.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-07-04T16:18:12+00:00</updated><id>https://hoonably.github.io/feed.xml</id><title type="html">hoonably</title><subtitle>Undergraduate student at UNIST (CSE), interested in AI, optimization, and systems programming. </subtitle><entry><title type="html">Various techniques in al-folio</title><link href="https://hoonably.github.io/blog/al-folio-tech/" rel="alternate" type="text/html" title="Various techniques in al-folio"/><published>2025-06-28T06:32:13+00:00</published><updated>2025-06-28T06:32:13+00:00</updated><id>https://hoonably.github.io/blog/al-folio-tech</id><content type="html" xml:base="https://hoonably.github.io/blog/al-folio-tech/"><![CDATA[<p>al-folio로 블로그를 바꾼 후 신기한 기능들이 많아서 정리를 해보고자 <a href="https://alshedivat.github.io/al-folio/blog/">https://alshedivat.github.io/al-folio/blog/</a>에 있는 기능들을 모아봤다.</p> <h2 id="detail-box">detail box</h2> <details><summary>Click here to know more</summary> <p>Additional details, where math \(2x - 1\) and <code class="language-plaintext highlighter-rouge">code</code> is rendered correctly.</p> </details> <hr/> <h2 id="custom-blockquotes">custom blockquotes</h2> <blockquote class="block-tip"> <p><strong>TIP</strong></p> <p>A tip can be used when you want to give advice related to a certain content.</p> </blockquote> <blockquote class="block-warning"> <p><strong>WARNING</strong></p> <p>This is a warning, and thus should be used when you want to warn the user</p> </blockquote> <blockquote class="block-danger"> <p><strong>DANGER</strong></p> <p>This is a danger zone, and thus should be used carefully</p> </blockquote> <hr/> <h2 id="tabs">tabs</h2> <ul id="log" class="tab" data-tab="70f16e84-8fd7-4fe5-ad71-423f972705f5" data-name="log"> <li class="active" id="log-php"> <a href="#">php </a> </li> <li id="log-js"> <a href="#">js </a> </li> <li id="log-ruby"> <a href="#">ruby </a> </li> </ul> <ul class="tab-content" id="70f16e84-8fd7-4fe5-ad71-423f972705f5" data-name="log"> <li class="active"> <div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">var_dump</span><span class="p">(</span><span class="s1">'hello'</span><span class="p">);</span>
</code></pre></div></div> </li> <li> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nf">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">hello</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div> </li> <li> <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">pputs</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span>
</code></pre></div></div> </li> </ul> <hr/> <h2 id="pseudocode">pseudocode</h2> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">pseudocode</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div> <pre><code class="language-pseudocode">% This quicksort algorithm is extracted from Chapter 7, Introduction to Algorithms (3rd edition)
\begin{algorithm}
\caption{Quicksort}
\begin{algorithmic}
\PROCEDURE{Quicksort}{$$A, p, r$$}
    \IF{$$p &lt; r$$}
        \STATE $$q = $$ \CALL{Partition}{$$A, p, r$$}
        \STATE \CALL{Quicksort}{$$A, p, q - 1$$}
        \STATE \CALL{Quicksort}{$$A, q + 1, r$$}
    \ENDIF
\ENDPROCEDURE
\PROCEDURE{Partition}{$$A, p, r$$}
    \STATE $$x = A[r]$$
    \STATE $$i = p - 1$$
    \FOR{$$j = p$$ \TO $$r - 1$$}
        \IF{$$A[j] &lt; x$$}
            \STATE $$i = i + 1$$
            \STATE exchange
            $$A[i]$$ with $$A[j]$$
        \ENDIF
        \STATE exchange $$A[i]$$ with $$A[r]$$
    \ENDFOR
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</code></pre> <hr/> <h2 id="image-video-audio">Image, Video, Audio</h2> <h3 id="single-image">single image</h3> <figure> <picture> <img src="/assets/img/logo/UNIST_logo.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="multiple-image">multiple image</h3> <p>2~3개의 이미지를 같은 줄에 넣기</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/logo/UNIST_logo.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/assets/img/logo/UAI_logo2.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <hr/> <h3 id="swiper-container">swiper-container</h3> <p>이미지 여러장 옆으로 넘기면서 보기</p> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">images</span><span class="pi">:</span>
  <span class="na">slider</span><span class="pi">:</span> <span class="kc">true</span>  <span class="c1"># 이미지 여러장 옆으로 넘기면서 보기</span>
</code></pre></div></div> <swiper-container keyboard="true" navigation="true" pagination="true" pagination-clickable="true" pagination-dynamic-bullets="true" rewind="true"> <swiper-slide> <figure> <picture> <img src="/assets/img/logo/UAI_logo2.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <img src="/assets/img/logo/UNIST_logo.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> <swiper-slide> <figure> <picture> <img src="/assets/img/logo/Topmath.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </swiper-slide> </swiper-container> <h3 id="img-comparison-slider">img-comparison-slider</h3> <p>좌우로 슬라이더로 비교</p> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">images</span><span class="pi">:</span>
  <span class="na">compare</span><span class="pi">:</span> <span class="kc">true</span>  <span class="c1"># 좌우로 슬라이드하면서 흑백 변경같은거</span>
</code></pre></div></div> <img-comparison-slider> <figure slot="first"> <picture> <img src="/assets/img/logo/UNIST_logo.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure slot="second"> <picture> <img src="/assets/img/logo/UAI_logo2.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </img-comparison-slider> <hr/> <h3 id="video">video</h3> <p>유튜브 링크를 그대로 가져올 경우 다음과 같은 embed 링크로 변환해줘야함</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://youtu.be/kCc8FmEb1nY → https://www.youtube.com/embed/kCc8FmEb1nY
</code></pre></div></div> <figure> <div style="position: relative; width: 100%; padding-bottom: 56.25%; height: 0;"> <iframe src="https://www.youtube.com/embed/kCc8FmEb1nY" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" class="img-fluid rounded z-depth-1" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe> </div> </figure> <hr/> <h3 id="audio">audio</h3> <figure> <audio src="https://cdn.pixabay.com/download/audio/2022/06/25/audio_69a61cd6d6.mp3" controls=""/> </figure> <hr/> <h2 id="code_diff">code_diff</h2> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">code_diff</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div> <ul> <li>diff 사용 <div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh">diff --git a/sample.js b/sample.js
index 0000001..0ddf2ba
</span><span class="gd">--- a/sample.js
</span><span class="gi">+++ b/sample.js
</span><span class="p">@@ -1 +1 @@</span>
<span class="gd">-console.log("Hello World!")
</span><span class="gi">+console.log("Hello from Diff2Html!")
</span></code></pre></div> </div> </li> <li>diff2html 사용 <pre><code class="language-diff2html">diff --git a/sample.js b/sample.js
index 0000001..0ddf2ba
--- a/sample.js
+++ b/sample.js
@@ -1 +1 @@
-console.log("Hello World!")
+console.log("Hello from Diff2Html!")
</code></pre> </li> </ul> <hr/> <h2 id="typograms">typograms</h2> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">typograms</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div> <pre><code class="language-typograms">.------------------------.
|.----------------------.|
||"https://example.com" ||
|'----------------------'|
| ______________________ |
||                      ||
||   Welcome!           ||
||                      ||
||                      ||
||  .----------------.  ||
||  | username       |  ||
||  '----------------'  ||
||  .----------------.  ||
||  |"*******"       |  ||
||  '----------------'  ||
||                      ||
||  .----------------.  ||
||  |   "Sign-up"    |  ||
||  '----------------'  ||
||                      ||
|+----------------------+|
.------------------------.
</code></pre> <hr/> <h2 id="chart">Chart</h2> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">chart</span><span class="pi">:</span>
  <span class="na">echarts</span><span class="pi">:</span> <span class="kc">true</span>
  <span class="na">chartjs</span><span class="pi">:</span> <span class="kc">true</span>
  <span class="na">plotly</span><span class="pi">:</span> <span class="kc">true</span>
  <span class="na">vega_lite</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div> <h3 id="echarts">echarts</h3> <pre><code class="language-echarts">{
  "title": {
    "text": "ECharts Getting Started Example"
  },
  "responsive": true,
  "tooltip": {},
  "legend": {
    "top": "30px",
    "data": ["sales"]
  },
  "xAxis": {
    "data": ["Shirts", "Cardigans", "Chiffons", "Pants", "Heels", "Socks"]
  },
  "yAxis": {},
  "series": [
    {
      "name": "sales",
      "type": "bar",
      "data": [5, 20, 36, 10, 10, 20]
    }
  ]
}
</code></pre> <h3 id="chartjs">chartjs</h3> <pre><code class="language-chartjs">{
  "type": "line",
  "data": {
    "labels": [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July"
    ],
    "datasets": [
      {
        "label": "# of bugs",
        "fill": false,
        "lineTension": 0.1,
        "backgroundColor": "rgba(75,192,192,0.4)",
        "borderColor": "rgba(75,192,192,1)",
        "borderCapStyle": "butt",
        "borderDash": [],
        "borderDashOffset": 0,
        "borderJoinStyle": "miter",
        "pointBorderColor": "rgba(75,192,192,1)",
        "pointBackgroundColor": "#fff",
        "pointBorderWidth": 1,
        "pointHoverRadius": 5,
        "pointHoverBackgroundColor": "rgba(75,192,192,1)",
        "pointHoverBorderColor": "rgba(220,220,220,1)",
        "pointHoverBorderWidth": 2,
        "pointRadius": 1,
        "pointHitRadius": 10,
        "data": [
          65,
          59,
          80,
          81,
          56,
          55,
          40
        ],
        "spanGaps": false
      }
    ]
  },
  "options": {}
}
</code></pre> <h3 id="plotly">plotly</h3> <pre><code class="language-plotly">{
  "data": [
    {
      "x": [1, 2, 3, 4],
      "y": [10, 15, 13, 17],
      "mode": "markers"
    },
    {
      "x": [2, 3, 4, 5],
      "y": [16, 5, 11, 9],
      "mode": "lines"
    },
    {
      "x": [1, 2, 3, 4],
      "y": [12, 9, 15, 12],
      "mode": "lines+markers"
    }
  ],
  "layout": {
    "title": {
      "text": "Line and Scatter Plot"
    }
  }
}
</code></pre> <h3 id="vega_lite">vega_lite</h3> <pre><code class="language-vega_lite">{
  "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
  "description": "A dot plot showing each movie in the database, and the difference from the average movie rating. The display is sorted by year to visualize everything in sequential order. The graph is for all Movies before 2019.",
  "data": {
    "url": "https://raw.githubusercontent.com/vega/vega/main/docs/data/movies.json"
  },
  "transform": [
    {"filter": "datum['IMDB Rating'] != null"},
    {"filter": {"timeUnit": "year", "field": "Release Date", "range": [null, 2019]}},
    {
      "joinaggregate": [{
        "op": "mean",
        "field": "IMDB Rating",
        "as": "AverageRating"
      }]
    },
    {
      "calculate": "datum['IMDB Rating'] - datum.AverageRating",
      "as": "RatingDelta"
    }
  ],
  "mark": "point",
  "encoding": {
    "x": {
      "field": "Release Date",
      "type": "temporal"
    },
    "y": {
      "field": "RatingDelta",
      "type": "quantitative",
      "title": "Rating Delta"
    },
    "color": {
      "field": "RatingDelta",
      "type": "quantitative",
      "scale": {"domainMid": 0},
      "title": "Rating Delta"
    }
  }
}
</code></pre> <hr/> <h2 id="mermaid-diagrams">mermaid (diagrams)</h2> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">mermaid</span><span class="pi">:</span>
  <span class="na">enabled</span><span class="pi">:</span> <span class="kc">true</span>
  <span class="na">zoomable</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div> <pre><code class="language-mermaid">sequenceDiagram
    participant John
    participant Alice
    Alice-&gt;&gt;John: Hello John, how are you?
    John--&gt;&gt;Alice: Great!
</code></pre> <pre><code class="language-mermaid">gantt
    dateFormat  YYYY-MM-DD
    title A Gantt Diagram

    section Section
    Task A           :a1, 2025-01-01, 30d
    Task B           :after a1, 20d
    Task C           :2025-01-10, 12d
</code></pre> <hr/> <h2 id="detail-codeblock">detail codeblock</h2> <p>lineos를 통해 줄번호 입력 가능하지만, <code class="language-plaintext highlighter-rouge">pretty_table: true</code> 해주면 선이 보여서 별로임</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="err">\</span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="n">string</span> <span class="n">myString</span><span class="p">;</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"input a string: "</span><span class="p">;</span>
    <span class="n">getline</span><span class="p">(</span><span class="n">cin</span><span class="p">,</span> <span class="n">myString</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">myString</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>

    <span class="kt">char</span> <span class="n">charArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span> <span class="o">*</span> <span class="p">[</span><span class="n">length</span><span class="p">];</span>

    <span class="n">charArray</span> <span class="o">=</span> <span class="n">myString</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">charArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure> <hr/> <h2 id="toc">toc</h2> <p>목차를 어떻게 쓸건지임</p> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">toc</span><span class="pi">:</span>
  <span class="na">beginning</span><span class="pi">:</span> <span class="kc">true</span>  <span class="c1"># 맨 앞에 목차</span>
  <span class="na">sidebar</span><span class="pi">:</span> <span class="s">left</span>  <span class="c1"># 목차가 사이드바 왼쪽에 붙어있음</span>
</code></pre></div></div> <hr/> <h2 id="jupyter-notebook">jupyter notebook</h2> <div class="jupyter-notebook" style="position: relative; width: 100%; margin: 0 auto;"> <div class="jupyter-notebook-iframe-container"> <iframe src="/assets/jupyter/blog.ipynb.html" style="position: absolute; top: 0; left: 0; border-style: none;" width="100%" height="100%" onload="this.parentElement.style.paddingBottom = (this.contentWindow.document.documentElement.scrollHeight + 10) + 'px'"></iframe> </div> </div> <hr/> <h2 id="pretty_table">pretty_table</h2> <p>이걸 해야 표에 선이 생김</p> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">pretty_table</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div> <table> <thead> <tr> <th style="text-align: left">Left aligned</th> <th style="text-align: center">Center aligned</th> <th style="text-align: right">Right aligned</th> </tr> </thead> <tbody> <tr> <td style="text-align: left">Left 1</td> <td style="text-align: center">center 1</td> <td style="text-align: right">right 1</td> </tr> <tr> <td style="text-align: left">Left 2</td> <td style="text-align: center">center 2</td> <td style="text-align: right">right 2</td> </tr> <tr> <td style="text-align: left">Left 3</td> <td style="text-align: center">center 3</td> <td style="text-align: right">right 3</td> </tr> </tbody> </table> <table data-click-to-select="true" data-height="460" data-pagination="true" data-search="true" data-toggle="table" data-url="/assets/json/table_data.json"> <thead> <tr> <th data-checkbox="true"></th> <th data-field="id" data-halign="left" data-align="center" data-sortable="true">ID</th> <th data-field="name" data-halign="center" data-align="right" data-sortable="true">Item Name</th> <th data-field="price" data-halign="right" data-align="left" data-sortable="true">Item Price</th> </tr> </thead> </table> <hr/> <h2 id="redirect">Redirect</h2> <p>이런 식으로 쓰면 글 눌렀을 때 바로 그 경로로 가짐</p> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">redirect</span><span class="pi">:</span> <span class="s">/assets/pdf/example_pdf.pdf</span>
</code></pre></div></div> <h2 id="citation">Citation</h2> <div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">citation</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div> <p>이 아래 내용은 내가 안쓴건데 “이 사이트가 유용했다면 다음과 같은 방법으로 인용해주세요~” 라고 해줌<br/> 👇👇👇</p>]]></content><author><name></name></author><category term="Else"/><summary type="html"><![CDATA[al-folio로 블로그를 바꾼 후 신기한 기능들이 많아서 정리를 해보고자 https://alshedivat.github.io/al-folio/blog/에 있는 기능들을 모아봤다.]]></summary></entry><entry><title type="html">SANA: Efficient High-Resolution Image Synthesis with Linear Diffusion Transformers</title><link href="https://hoonably.github.io/blog/sana/" rel="alternate" type="text/html" title="SANA: Efficient High-Resolution Image Synthesis with Linear Diffusion Transformers"/><published>2025-05-12T07:25:51+00:00</published><updated>2025-05-12T07:25:51+00:00</updated><id>https://hoonably.github.io/blog/sana</id><content type="html" xml:base="https://hoonably.github.io/blog/sana/"><![CDATA[<p>Authors: Enze Xie, Junsong Chen, Junyu Chen, Han Cai, Haotian Tang, Yujun Lin, Zhekai Zhang, Muyang Li, Ligeng Zhu, Yao Lu, Song Han Venue &amp; Year: 25, ICLR, Oral 날짜: 2025년 3월 15일</p> <table> <thead> <tr> <th>ArXiv</th> <th><a href="https://arxiv.org/abs/2410.10629">https://arxiv.org/abs/2410.10629</a></th> </tr> </thead> <tbody> <tr> <td>Project Page</td> <td><a href="https://nvlabs.github.io/Sana/">https://nvlabs.github.io/Sana/</a></td> </tr> <tr> <td>Github Code</td> <td><a href="https://github.com/NVlabs/Sana">https://github.com/NVlabs/Sana</a></td> </tr> </tbody> </table> <blockquote class="block-warning"> <p>💡</p> <p><strong>Key Differentiator</strong></p> <ol> <li> <p>Efficient Linear DiT design</p> <p>ReLU 기반 Linear Attention 도입</p> <p>Mix-FFN Block</p> </li> <li> <p>Deep Compression Autoencoder</p> <p>→ 이로 인한 32배 압축 가능으로 연산도 빨라짐</p> </li> </ol> </blockquote> <figure> <picture> <img src="/files/2025-05-12-sana/image.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>이번에는 SVDQuant의 저자인 Song Han이 또 일을 냈다.</p> <p>SANA 라는 Diffusion 모델을 NVIDIA에서 제작했는데, 역대급이다.</p> <p>내가 하려던 On-device 4K Diffusion 연구에도 크게 도움될 것 같아서 읽어보았다.</p> <h1 id="1-introduction">1. Introduction</h1> <p>지난 1년동안 Diffusion 모델은 text-to-image 연구에서 상당한 진전을 보임.</p> <p>하지만, 아래와 같이 상업 모델은 파라미터가 매우 커짐 → 높은 학습 및 추론 비용을 초래하여 비용이 많이 들음.</p> <blockquote> <p>Industry models are becoming increasingly large, with parameter counts escalating from PixArt’s 0.6B parameters to SD3 at 8B, LiDiT at 10B, Flux at 12B, and Playground v3 at 24B.</p> </blockquote> <p>cloud 뿐만 아니라 edge devices에서도 빠르게 실행되는 고해상도 image generator를 개발할 수 없을까?</p> <figure> <picture> <img src="/files/2025-05-12-sana/image%201.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>이 논문은 1024 × 1024 ~ 4096 × 4096 범위의 해상도에서 이미지를 효율적이고 비용 효율적으로 훈련하고 합성하도록 설계된 파이프 라인 인 SANA를 제안</p> <p>Pixart-σ (Chen et al., 2024a)를 제외하고는 4K 해상도 이미지 생성을 직접 탐색하지 못했습니다. 그러나 Pixart-σ는 4K 해상도에 가까운 이미지를 생성하는 것으로 제한되며 (3840 × 2160) 이러한 고해상도 이미지를 생성 할 때 비교적 느립니다. 이 야심 찬 목표를 달성하기 위해 몇 가지 핵심 디자인을 제안합니다.</p> <h1 id="2-methods">2. METHODS</h1> <h2 id="21-deep-compression-autoencoder">2.1 DEEP COMPRESSION AUTOENCODER</h2> <h3 id="211-preliminary">2.1.1 PRELIMINARY</h3> <p>원래 diffusion 모델은 이미지 픽셀 공간 (pixel space) 위에서 직접 작동 → 훈련, 추론 둘다 너무 느리고 무거움</p> <p><strong>Latent Diffusion Models</strong></p> <p>Autoencoder로 이미지 압축 후 압축된 latent 공간 위에서 diffusion을 돌리자!</p> <p>→ 8배 압축 사용</p> <figure> <picture> <img src="/files/2025-05-12-sana/image%202.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>Diffusion Transformer (DiT)</strong></p> <p>추가로 latent feature를 Patch 단위로 또 나눠서 처리</p> <p>패치크기가 PxP 라면 최종적으로 다루는 토큰 개수는</p> <figure> <picture> <img src="/files/2025-05-12-sana/image%203.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>기존 latent diffusion 모델들(PixArt, SD3, Flux 등)은 보통 다음 세팅을 씀</p> <ul> <li><strong>AE-F8C4P2</strong> 또는 <strong>AE-F8C16P2</strong> <ul> <li><strong>F8</strong>: Autoencoder가 8배 압축</li> <li><strong>C4</strong> 또는 <strong>C16</strong>: latent 채널 수 (4개나 16개)</li> <li><strong>P2</strong>: Patch 크기 2×2로 묶기</li> </ul> </li> </ul> <p>기존처럼 8배 압축만 하면 계산량이 여전히 너무 많음</p> <p>그래서 SANA는 과감하게 <strong>32배 압축(AE-F32)</strong>하고, 패치로는 묶지 않음.</p> <h3 id="212-autoencoder-design-philosophy">2.1.2 AUTOENCODER DESIGN PHILOSOPHY</h3> <table> <thead> <tr> <th>구분</th> <th>기존 (PixArt, Flux)</th> <th>SANA</th> </tr> </thead> <tbody> <tr> <td>AE 압축비</td> <td>8배 (F=8)</td> <td>32배 (F=32)</td> </tr> <tr> <td>Patchify (P=2)</td> <td>O (패치로 묶음)</td> <td>✖️ (패치 안 묶음)</td> </tr> <tr> <td>최종 Token 수</td> <td>줄였지만 아직 많음</td> <td>훨씬 적음 (16배 감소)</td> </tr> </tbody> </table> <figure> <picture> <img src="/files/2025-05-12-sana/image%204.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>위의 표를 보면 알 수 있듯이 32배 압축하더라도 점수가 크게 떨어지지 않는 모습을 보임</p> <h3 id="213-ablation-of-autoencoder-designs">2.1.3 ABLATION OF AUTOENCODER DESIGNS</h3> <ul> <li><strong>어디서 압축을 더 하는 게 좋은가? (AE vs DiT)</strong></li> </ul> <figure> <picture> <img src="/files/2025-05-12-sana/image%205.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <table> <thead> <tr> <th>설정</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td>AE-F8C16P4</td> <td>8배 압축 + 패치 크기 4</td> </tr> <tr> <td>AE-F16C32P2</td> <td>16배 압축 + 패치 크기 2</td> </tr> <tr> <td>AE-F32C32P1</td> <td>32배 압축 + 패치 사용하지 않음 (SANA)</td> </tr> </tbody> </table> <p>AE-F32C32P1 설정이 가장 뛰어난 성능(FID, CLIP Score)을 기록</p> <p>Autoencoder가 압축을 전적으로 담당하는 것이 성능 및 훈련 안정성 모두에서 가장 우수</p> <ul> <li><strong>Autoencoder latent 채널 수를 몇 개로 하는 게 좋은가?</strong></li> </ul> <figure> <picture> <img src="/files/2025-05-12-sana/image%206.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>C=16, C=32, C=64 실험 수행</li> <li>C=16은 정보 손실로 인해 품질 저하 발생</li> <li>C=64는 복원 품질은 좋았으나 모델 복잡도가 급격히 증가하여 비효율적임</li> <li>C=32가 성능과 효율 사이에서 최적 균형을 달성함</li> </ul> <h2 id="22-efficient-linear-dit-design">2.2 EFFICIENT LINEAR DIT DESIGN</h2> <ul> <li>기존 diffusion transformer(예: DiT) 구조는 <strong>Self-Attention</strong>을 사용함.</li> <li>Self-Attention의 연산량은 <strong>O(N²)</strong> 에 비례함. <ul> <li>NNN은 입력 토큰 수</li> <li>토큰 수가 많아지면 연산량이 급격히 커짐</li> </ul> </li> <li>4K 해상도 이미지를 다루려면, latent token 수가 많아질 수밖에 없음.</li> </ul> <p>→ 이때, 기존 연구들은 이 문제를 해결하려고 해상도 낮추거나 Token 수를 줄였음.</p> <h3 id="relu-기반-linear-attention-도입">ReLU 기반 Linear Attention 도입</h3> <p>기존 Softmax 기반 Attention을 제거하고, <strong>ReLU를 이용한 Linear Attention</strong>을 채택</p> <figure> <picture> <img src="/files/2025-05-12-sana/image%207.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>Softmax는 모든 Query-Token 조합을 다 계산하기 때문에 O(N²) 복잡도가 발생</p> <figure> <picture> <img src="/files/2025-05-12-sana/image%208.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>SANA에서는 다음처럼 계산 구조를 변경함</li> </ul> <ol> <li>각 Key에 ReLU를 적용함: <strong>ReLU(K)</strong></li> <li>두 가지 공유 term을 미리 계산</li> </ol> <figure> <picture> <img src="/files/2025-05-12-sana/image%209.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ol> <li>이후, 각 Query에 대해 이 pre-computed shared term을 재사용하여 Attention을 계산 <ul> <li>이 방식은 Query마다 개별적으로 연산할 필요가 없어서, 전체 Attention 계산이 <strong>O(N)</strong> 으로 줄어듦.</li> </ul> </li> </ol> <p><strong>PixArt도 Linear이랬는데 다른점은?</strong></p> <p>PixArt에서는 Key와 Value 토큰을 압축하여 연산량을 줄여서 Engineering Optimization으로 O(N)과 비슷하게 하는 방식, SANA에서는 아예 수학적으로 계산량이 O(N)</p> <h3 id="mix-ffn-block">Mix-FFN Block</h3> <figure> <picture> <img src="/files/2025-05-12-sana/image%2010.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>기존 Transformer의 FFN (Feed-Forward Network)은 단순히 2개의 Linear Layer로 구성되어 있었음.</p> <p>FFN은 전역적인 정보는 잘 처리하지만, <strong>지역적인(local) 디테일</strong> 복원에는 약했음.</p> <p>SANA의 해결책:</p> <ul> <li>기존 MLP 사이에 <strong>3×3 Depthwise Convolution</strong>을 삽입</li> <li>이를 통해 지역 구조(local structure) 학습을 강화</li> <li>결과적으로 <strong>텍스처, 경계선</strong>, 이런 세밀한 부분 복원에 유리</li> </ul> <h3 id="dit-without-positional-encoding-nope">DiT without Positional Encoding (NoPE)</h3> <p>기존 Transformer 구조는 입력 순서를 인식하도록 <strong>Positional Encoding</strong>을 사용했음.</p> <p>왜냐면 Transformer는 입력 순서를 구별할 수 없었기 때문에…</p> <p>하지만 4K 고해상도 latent처럼 토큰 수가 많을 때, Positional Encoding을 계산하고 저장하는 데도 비용이 큼.</p> <p>SANA에서는 아예 Positional Encoding을 제거함</p> <ul> <li><strong>3×3 Depthwise Convolution</strong>이 Mix-FFN에 추가되어서 지역적 위치 관계를 학습할 수 있음.</li> <li> <p>Linear Attention은 <strong>전역 관계</strong>를 자연스럽게 포착할 수 있음.</p> <p>→ 별도로 위치 정보를 부여하지 않아도 충분히 패턴과 구조를 학습할 수 있음.</p> </li> </ul> <p>결과적으로 품질이 유지되면서 구조가 간단해지고 메모리 연산량이 감소함</p> <figure> <picture> <img src="/files/2025-05-12-sana/image%2011.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="triton-acceleration-traininginference">Triton Acceleration Training/Inference</h3> <p>Appendix에 추가한다고 되어있는데 아직 관련 내용 없음.</p> <p>GPT가 알려준 내용</p> <ul> <li>Linear Attention을 구현할 때, 단순히 알고리즘만 개선하는 것으로는 부족함.</li> <li>실제 연산 효율까지 극대화하려면, <strong>GPU kernel 레벨 최적화</strong>가 필요함.</li> <li>SANA는 <strong>Triton</strong>을 사용하여 Linear Attention 연산을 직접 최적화함. <ul> <li>Triton은 NVIDIA가 지원하는 <strong>커스텀 GPU 커널 프로그래밍 프레임워크</strong>임.</li> <li>CUDA보다 단순한 문법으로, 고성능 커널을 작성할 수 있음.</li> </ul> </li> </ul> <p>Triton으로 최적화한 결과:</p> <ul> <li>Matrix 곱 연산(GEMM)과 Memory Access를 줄임.</li> <li>실제 latency(지연 시간)와 memory bandwidth 소모를 크게 개선</li> </ul> <h2 id="23-text-encoder-design">2.3 TEXT ENCODER DESIGN</h2> <h3 id="왜-t5-대신-decoder-only-llm을-사용하는가"><strong>왜 T5 대신 Decoder-only LLM을 사용하는가?</strong></h3> <p>SANA는 Gemma를 Text Encoder로 사용하기로 채택</p> <table> <thead> <tr> <th>항목</th> <th>기존 (T5)</th> <th>SANA (Gemma-2)</th> </tr> </thead> <tbody> <tr> <td>모델 구조</td> <td>Encoder-Decoder</td> <td>Decoder-only</td> </tr> <tr> <td>Reasoning 능력</td> <td>제한적</td> <td>매우 강함 (CoT, ICL 가능)</td> </tr> <tr> <td>추론 속도</td> <td>느림 (T5-XXL)</td> <td>6배 빠름 (Gemma-2-2B)</td> </tr> </tbody> </table> <figure> <picture> <img src="/files/2025-05-12-sana/image%2012.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>→ 빠른데도 불구하고, CLIP Score와 FID(이미지 품질 지표)에서는 <strong>성능이 비슷함</strong></p> <h3 id="decoder-only-llm을-text-encoder로-쓰면서-생긴-문제-해결">Decoder-only LLM을 Text Encoder로 쓰면서 생긴 문제 해결</h3> <p>Decoder-only LLM (Gemma, Qwen 등)의 텍스트 임베딩은 Variance가 훨씬 큼.</p> <ul> <li>큰 값이 텍스트 임베딩 안에 많이 포함되어 있음.</li> <li>Cross-Attention 연산 중 수치 폭발(NaN)로 이어짐.</li> </ul> <p><strong>방법 1: RMSNorm 추가</strong></p> <p>Gemma-2의 텍스트 임베딩 출력에 <strong>RMSNorm</strong>을 적용</p> <p>RMSNorm?</p> <ul> <li>입력 벡터의 Variance를 1.0으로 정규화</li> <li>큰 값이나 작은 값들을 균일하게 만들어 수치 폭발 방지</li> </ul> <p><strong>방법 2: Learnable Scale Factor 추가</strong></p> <ul> <li>추가로, 텍스트 임베딩에 <strong>학습 가능한 작은 스케일 파라미터</strong>를 곱함</li> <li>초기 값은 매우 작게 설정함 (예: 0.01)</li> <li>이 파라미터가 학습을 통해 적절한 크기로 조정되면서 모델 수렴 속도가 빨라짐</li> </ul> <p>→ 훈련 안정성 확보 + 수렴 속도 향상</p> <figure> <picture> <img src="/files/2025-05-12-sana/image%2013.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="complex-human-instruction-improves-text-image-alignment">Complex Human Instruction Improves Text-Image Alignment</h3> <p>Gemma는 강력한 LLM이지만, 사용자가 짧거나 모호한 프롬프트를 입력하면 (예: “a cat”)</p> <p>LLM이 초점을 잃고 엉뚱한 답변을 할 수도 있음.</p> <p>→ LLM이 프롬프트에만 집중하게 만드는 추가 지시문이 필요함.</p> <p><strong>CHI가 그래서 뭔디?</strong></p> <p>LLM의 <strong>In-Context Learning</strong> 능력을 활용하여 프롬프트를 주기 전에,</p> <p>LLM에게 “색상, 크기, 위치 관계 같은 세부 묘사를 추가해라”와 같은 <strong>복잡한 명령 세트</strong>를 함께 제공하는 것</p> <p><strong>결과 1</strong></p> <figure> <picture> <img src="/files/2025-05-12-sana/image%2014.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>CHI를 적용했을 때, 학습을 처음부터 하든(fresh training)</p> <p>아니면 기존 모델을 미세 조정(fine-tuning)하든</p> <p><strong>텍스트-이미지 정렬 성능이 향상</strong></p> <p><strong>결과 2</strong></p> <figure> <picture> <img src="/files/2025-05-12-sana/image%2015.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>짧은 프롬프트(예: “a cat”)를 입력했을 때,</p> <p>CHI가 없으면, 모델이 엉뚱한 이미지를 생성하거나 품질이 불안정해짐.</p> <p>CHI가 있으면, 모델이 <strong>프롬프트에 정확히 맞는 안정적인 이미지</strong>를 생성</p> <h1 id="3-efficient-traininginference">3 EFFICIENT TRAINING/INFERENCE</h1> <h2 id="31-data-curation-and-blending">3.1 DATA CURATION AND BLENDING</h2> <h3 id="1-multi-caption-auto-labelling-pipeline">1. Multi-Caption Auto-labelling Pipeline</h3> <p><strong>이미지 하나당 4개의 VLM(Vision-Language Models) 을 이용해 캡션을 생성함.</strong></p> <ul> <li><strong>VILA-3B</strong></li> <li><strong>VILA-13B</strong></li> <li><strong>InternVL-28B</strong></li> <li><strong>InternVL-26B</strong></li> </ul> <p><strong>→ 정확한 캡션</strong> 생성 (하나만 쓰는 것보다 오류 줄임)</p> <p><strong>→ 다양한 표현</strong> 확보 (같은 이미지를 여러 관점에서 묘사 가능)</p> <hr/> <h3 id="2-clip-score-based-caption-sampler">2. CLIP-Score-based Caption Sampler</h3> <p><strong>문제 상황</strong></p> <ul> <li> <p>캡션을 여러 개 만들었는데,</p> <p>훈련할 때 어떤 캡션을 선택할지가 문제임.</p> </li> <li> <p>무작위로(random) 하나 고르면:</p> <ul> <li>품질이 낮은 문장을 뽑을 위험이 있음</li> <li>그러면 훈련이 느려지거나 모델 품질이 떨어짐</li> </ul> </li> </ul> <p><strong>해결 방법</strong></p> <ul> <li><strong>CLIP score</strong>를 활용해 품질 높은 캡션을 뽑는 방식 사용 <ul> <li>CLIP은 이미지-텍스트 매칭 정도를 점수로 계산해줌.</li> </ul> </li> <li>과정: <ol> <li>이미지에 대해 생성된 각 캡션의 CLIP 점수(cic_ici)를 계산</li> <li>점수가 높은 캡션일수록 뽑힐 확률이 높게 설정</li> <li>Sampling 확률 공식:</li> </ol> </li> </ul> <figure> <picture> <img src="/files/2025-05-12-sana/image%2016.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>여기</p> <ul> <li>τ는 “temperature”라는 하이퍼파라미터임.</li> <li><strong>Temperature 조정으로 뽑는 강도를 조절</strong>할 수 있음: <ul> <li>τ가 작으면: 점수 가장 높은 캡션만 거의 항상 선택</li> <li>τ가 크면: 다양한 캡션이 고르게 선택됨</li> </ul> </li> </ul> <hr/> <h3 id="실험-결과">실험 결과</h3> <ul> <li>Table 4 결과에 따르면: <ul> <li>캡션을 다양하게 골라도 이미지 품질(FID)은 거의 변하지 않음</li> <li>하지만 <strong>훈련 중 텍스트-이미지 정렬</strong>(semantic alignment)은 훨씬 좋아짐</li> </ul> </li> </ul> <hr/> <h3 id="3-cascade-resolution-training"><strong>3. Cascade Resolution Training</strong></h3> <h3 id="기존-방식">기존 방식</h3> <ul> <li>대부분의 diffusion 모델은 해상도 256px짜리 이미지로 먼저 pre-training을 함.</li> <li>이유는 연산 비용(cost)을 줄이기 위해서임.</li> </ul> <h3 id="문제점">문제점</h3> <ul> <li>256px 이미지는 디테일(detail) 손실이 심함.</li> <li>따라서, 작은 해상도에서 학습을 시작하면: <ul> <li>모델이 fine한 구조나 텍스처를 배우기 어려움</li> <li>결국 큰 해상도로 갈 때 더 느리게 학습함.</li> </ul> </li> </ul> <hr/> <h3 id="sana-방식">SANA 방식</h3> <ul> <li> <p>SANA는 <strong>AE-F32C32P1 구조</strong>를 사용하기 때문에</p> <p>latent 공간이 매우 작음 → 연산 부담이 적음.</p> </li> <li>그래서 굳이 256px에서 시작할 필요 없이 바로 <strong>512px</strong>에서 학습 시작함.</li> <li>학습 순서: <ul> <li>512px → 1024px → 2K → 4K 순서로 점진적(fine-tuning)으로 해상도를 올림.</li> </ul> </li> </ul> <h2 id="32-flow-based-training--inference">3.2 FLOW-BASED TRAINING / INFERENCE</h2> <h3 id="flow-based-training">Flow-based Training</h3> <p>기존 방식 : noise prediction</p> <figure> <picture> <img src="/files/2025-05-12-sana/image%2017.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-05-12-sana/image%2018.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-05-12-sana/image%2019.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>→ 노이즈를 맞추는 것이 학습 목표</p> <p>문제점 : t가 커지면 (Diffusion 마지막 단계에 가까우면) 노이즈가 커져서 예측 불안정</p> <p>새 방식 : EDM ,RF</p> <p>noise 대신 data나 velocity(노이즈와 원본 이미지 차이) 예측</p> <figure> <picture> <img src="/files/2025-05-12-sana/image%2020.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-05-12-sana/image%2021.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-05-12-sana/image%2022.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>결국 RF를 사용하여 cumulative(누적) error를 줄일 수 있음</p> <h3 id="flow-based-inference">Flow-based Inference</h3> <p>기존 : DPM-Solver++</p> <p>→ required 28-50 steps for high-quality samples</p> <p>현재 : <strong>Flow-DPM-Solver</strong></p> <p>1.Not predict original data, but velocity</p> <p>2.substituting the scaling factor αt with 1 − σt</p> <p>3.time-steps are redefined over the range [0, 1] instead of [1, 1000]</p> <p>→Generate high-quality samples in 14-20 steps</p> <h1 id="5-experiments">5. Experiments</h1> <h2 id="1-model-details">1. Model Details</h2> <h3 id="sana-06b">Sana-0.6B</h3> <ul> <li>파라미터 수: <strong>590M</strong></li> <li>구조: <strong>DiT-XL</strong> 및 <strong>PixArt-Σ</strong>와 거의 동일한 레이어 수와 채널 수 사용</li> <li>목적: 소형 모델로도 효율성과 품질을 동시에 확보</li> </ul> <h3 id="sana-16b">Sana-1.6B</h3> <ul> <li>파라미터 수: <strong>1.6B</strong></li> <li>구조: <ul> <li><strong>20개의 Transformer 레이어</strong></li> <li>각 레이어마다 <strong>2240개의 채널</strong></li> <li>FFN 내부 채널 수는 <strong>5600</strong></li> </ul> </li> <li>이 구성은 학습 효율성과 생성 품질 사이의 균형을 고려한 것임</li> </ul> <h2 id="2-evaluation-details">2. Evaluation Details</h2> <p>SANA는 총 <strong>5가지 대표적인 평가 지표</strong>를 사용하여 성능을 평가함.</p> <table> <thead> <tr> <th>지표</th> <th>설명</th> </tr> </thead> <tbody> <tr> <td><strong>FID (Fréchet Inception Distance)</strong></td> <td>이미지 품질을 수치로 측정. 낮을수록 좋음</td> </tr> <tr> <td><strong>CLIP Score</strong></td> <td>이미지와 텍스트 간 의미적 정렬 정도 평가. 높을수록 좋음</td> </tr> <tr> <td><strong>GenEval</strong> (Ghosh et al., 2024)</td> <td>텍스트-이미지 정렬 평가. 총 533개의 프롬프트 사용</td> </tr> <tr> <td><strong>DPG-Bench</strong> (Hu et al., 2024)</td> <td>텍스트-이미지 정렬 정밀도 테스트. 1065개의 프롬프트 사용</td> </tr> <tr> <td><strong>ImageReward</strong> (Xu et al., 2024)</td> <td>인간의 주관적 선호도를 반영한 점수. 100개 프롬프트로 측정</td> </tr> </tbody> </table> <h2 id="3-평가-데이터셋">3. 평가 데이터셋</h2> <ul> <li><strong>MJHQ-30K (Li et al., 2024a)</strong> <ul> <li>Midjourney에서 수집한 <strong>30,000개 고품질 이미지</strong> 포함</li> <li>FID, CLIP Score 측정에 사용됨</li> </ul> </li> </ul> <figure> <picture> <img src="/files/2025-05-12-sana/image%2023.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-05-12-sana/image%2024.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h1 id="limitation">Limitation</h1> <figure> <picture> <img src="/files/2025-05-12-sana/image%2025.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><a href="https://x.com/cloneofsimo/status/1864309440356470894?s=46">https://x.com/cloneofsimo/status/1864309440356470894?s=46</a></p> <p>코드가 전반적으로 NVIDIA칩만을 위해 설계되어</p> <p>다른 GPU 장비는 물론이고,</p> <p>Mobile Device에서는 당연히 불가능함.</p> <p>아무래도 NVIDIA에서 낸 논문이기 때문에 Blackwell chip 홍보 겸 NVIDIA chip에서만 가능하도록 한듯.</p>]]></content><author><name></name></author><category term="Paper"/><category term="AI"/><summary type="html"><![CDATA[Authors: Enze Xie, Junsong Chen, Junyu Chen, Han Cai, Haotian Tang, Yujun Lin, Zhekai Zhang, Muyang Li, Ligeng Zhu, Yao Lu, Song Han Venue &amp; Year: 25, ICLR, Oral 날짜: 2025년 3월 15일]]></summary></entry><entry><title type="html">Mac 초기설정 + 유용한 프로그램</title><link href="https://hoonably.github.io/blog/mac-setting/" rel="alternate" type="text/html" title="Mac 초기설정 + 유용한 프로그램"/><published>2025-04-13T07:24:31+00:00</published><updated>2025-04-13T07:24:31+00:00</updated><id>https://hoonably.github.io/blog/mac-setting</id><content type="html" xml:base="https://hoonably.github.io/blog/mac-setting/"><![CDATA[<blockquote class="block-warning"> <p>💡</p> <p>MacBook Pro 14 inch M2 Pro (2023)</p> <p><code class="language-plaintext highlighter-rouge">Sequoia 15.3.1</code> Version</p> <p>버전이 다르다면 다를 수 있음</p> <p>어플 내 상세 설정은 내가 선호하는 대로 기록하려고 캡쳐해둠</p> <p>어느정도 컴퓨터를 다룰 줄 아는 사람이라는 전제 하에 작성</p> <p>(ex. Github 오픈소스니까 링크 들어가서 최신 버전 다운받기)</p> <p>Homebrew 등 다루는것도 있는데 궁금하면 알아서 GPT gogo</p> </blockquote> <h1 id="프로그램-다운로드-종류">프로그램 다운로드 종류</h1> <p>설정과 좋은 어플을 소개하기 전에 맥 기본 프로그램 다운로드 종류를 알려주겠다.</p> <p>앱스토어로 다운은 생각보다 별로 없으니까 일단 넘기고,</p> <p>맥은 소프트웨어를 다운받았을 경우, 직접 <code class="language-plaintext highlighter-rouge">응용 프로그램</code> 폴더에 넣어줘야한다.</p> <p>프로그램별로 보통 세가지 방식이 있다.</p> <ol> <li> <p><code class="language-plaintext highlighter-rouge">.pkg</code> 파일 : 우리가 아는 평범한 설치 프로그램.</p> <p>근데 맥에서는 은근 잘 안쓰인다.</p> </li> </ol> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%201.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ol> <li> <p><code class="language-plaintext highlighter-rouge">.dmg</code> 파일 : 친절하게 넣도록 유도</p> <p>→ 다음처럼 친절하게 드래그드롭으로 넣도록 유도해준다.</p> </li> </ol> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%202.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%203.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ol> <li> <p><code class="language-plaintext highlighter-rouge">.zip</code> 파일 : 알아서 넣기</p> <p>→ 다음과같이 zip 파일만 딸랑 있을때, 압축을 풀었는데 바로 응용 프로그램이 나온다면</p> <p>→ 직접 <code class="language-plaintext highlighter-rouge">응용 프로그램</code> 폴더에 드래그드랍 해주자.</p> </li> </ol> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%204.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%205.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>다음과 같이 <code class="language-plaintext highlighter-rouge">응용 프로그램</code> 폴더에 들어가면 <code class="language-plaintext highlighter-rouge">LaunchPad</code>에 보인다.</p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%206.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%207.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h1 id="️-software-update">⭐️ Software Update</h1> <p>업데이트 일부러 안하는 사람도 있는데, 개인적으로는 추천한다.</p> <p>계속 안하고 버티면 안돌아가는 어플들이 꽤 있다.</p> <p>오래걸릴 수 있으니 미리 다운로드 시작하고 아래 진행</p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%208.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h1 id="️설정">⚙️ 설정</h1> <ul> <li> <p>Apple Login</p> <p>이거부터 하고 시작하자.</p> </li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-02-22_%EC%98%A4%ED%9B%84_5.44.03.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li> <p>시동음 제거</p> <p>노트북 켰을때 이거 안해놓으면 밖에서 관종처럼 시끄럽게 킬 수 있다.</p> </li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%209.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li> <p>키보드 → 키보드 단축키</p> <p>이건 내 나름대로 선호하는 설정이다.</p> </li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2010.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2011.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2012.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li> <p>핫 코너 단축키</p> <p>마우스로 코너를 찍어서 Mission Control이나 데스크탑 보기를 할 수 있는데, 정말 유용하다.</p> </li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2013.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li> <p>앱스토어 암호 없이 다운로드</p> <p>이 과정을 해줘야 앱스토어에서 앱 설치시 귀찮게 자꾸 암호를 입력하는 일이 없다.</p> <p>미디어 및 구입 항목 → 무료 다운로드 → 입력 안함</p> </li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2014.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li> <p><strong>문서(PDF) 탭으로 열기</strong></p> <p>PDF를 열때 윈도우는 자동으로 하나의 창에 여러 탭으로 열리는데,</p> <p>맥은 이 설정을 안해주면 각각 다른 창으로 열린다.</p> </li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2015.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h1 id="️scroll-reverser-설치">🖱️ Scroll Reverser 설치</h1> <p>트랙패드 스크롤은 그대로 두고 마우스 휠만 반전시켜서 윈도우랑 일치하도록 할 수 있음</p> <p>Mac 소프트웨어 버전 낮으면 실행 안됨 13.xx 에서 안됐음</p> <p><a href="https://pilotmoon.com/scrollreverser/">https://pilotmoon.com/scrollreverser/</a></p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2016.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2017.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h1 id="️우command--한영키로">⌨️ 우command → 한영키로</h1> <ul> <li> <p>Karabiner 버전에 맞게 다운로드</p> <p><a href="https://karabiner-elements.pqrs.org/">https://karabiner-elements.pqrs.org/</a></p> </li> <li> <p>여러 권한 부여 작업</p> </li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2018.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2019.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>다음과 같이 설정</li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2020.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2021.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>참고로 몇몇 키보드는 바로 허용이 안되서 직접 Device에 들어가서 <code class="language-plaintext highlighter-rouge">Modify events</code> 해줘야함!!</li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2022.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>설정 → 키보드 → 키보드 단축키</li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2023.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><code class="language-plaintext highlighter-rouge">F18</code> 하는 방법 : 위에서 설정했던 <code class="language-plaintext highlighter-rouge">우커맨드</code> 누르면 됨</p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2024.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>키보드 → 입력 소스 → 편집</li> </ul> <p>한영키 우커맨드로만 쓸거면 Caps Lock 쓸 수 있음</p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2025.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h1 id="finder">📁 Finder</h1> <ul> <li>도구 막대 사용자화</li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2026.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2027.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2028.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>경로 막대 보기, 상태막대 보기로 변경 → 아래 경로랑 용량 나옴</li> </ul> <p>왼쪽 위의 메뉴바에 보기 누르면 저렇게 나옴</p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2029.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>항상 자동으로 정렬</li> </ul> <p>우클릭 → 보기 옵션 → 정렬 → 이름 등 원하는 걸로</p> <p>→ 아래 <code class="language-plaintext highlighter-rouge">기본값으로 사용</code> 누르기</p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2030.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>파인더에서 단축키로 바로 그 경로의 터미널 열기 (컴공이면 Good)</li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2031.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2032.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>반드시 먼저 설정한 항목을 글자 그래도 옮겨적어야한다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>폴더에서 새로운 터미널 탭 열기
</code></pre></div></div> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2033.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2034.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>위처럼 폴더를 누른 후 설정한 단축어를 사용하면 바로 터미널이 열린다.</p> <hr/> <h1 id="️-rectangle">⬛️ Rectangle</h1> <p>맥 소프트웨어 업데이트하면서 기본 설정에서도 있는데, 이 어플이 더 최적화가 부드럽고 기능이 많음</p> <p><a href="https://rectangleapp.com/">https://rectangleapp.com/</a></p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2035.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2036.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2037.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h1 id="️keyboardcleantool">⌨️ KeyBoardCleanTool</h1> <p>맥북은 키보드를 누르기만 하면 노트북이 켜져버리기 때문에 키보드 청소하기가 불편하다.</p> <p>키보드를 아예 꺼버리고 물티슈 등으로 청소할 수 있다.</p> <p>(전원키는 이거 실행해도 눌리는듯 하니까 조심)</p> <p><a href="https://folivora.ai/keyboardcleantool">https://folivora.ai/keyboardcleantool</a></p> <p>다운로드 후 압축풀면 바로 어플리케이션인데, 경로를 ‘응용 프로그램’으로 옮겨주면 된다.</p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2038.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h1 id="grey">🐨 Grey</h1> <p>어플들은 대부분 기본 설정으로 시스템이 다크모드면 다크모드를 따라가도록 되어있고, 설정에서 라이트/다크 모드를 고정할 수도 있다.</p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2039.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>하지만, 인기가 없는 앱은 무조건 시스템 설정을 따라가는 경우가 있다. (ex. QTSpim)</p> <p>컴구 과제때문에 QTSpim을 깔아서 하는데, 다크모드를 항상 쓰는 나에게는 코드 보기가 눈이 너무 아팠고, 이거 하나때문에 다크모드를 끄자니 싫었다.</p> <p>이를 해결하는 각 어플마다 시스템 설정을 다르게 설정해주는 어플이다.</p> <ul> <li>다운로드</li> </ul> <p><a href="https://github.com/zenangst/Gray?tab=readme-ov-file">https://github.com/zenangst/Gray?tab=readme-ov-file</a></p> <hr/> <h1 id="appcleaner">🧹 AppCleaner</h1> <p>앱만 드래그로 지우면 앱 파일이 많은 용량을 차지할 수 있다. 자동으로 찾아서 지우도록 도와주는 어플</p> <p><a href="https://freemacsoft.net/appcleaner/">https://freemacsoft.net/appcleaner/</a></p> <hr/> <h1 id="aldente">🔋 AlDente</h1> <p>맥북 필수 배터리 관리 앱</p> <p><a href="https://apphousekitchen.com/">https://apphousekitchen.com/</a></p> <p>난 클램쉘로 쓰니까 편하게 하려고 결제도 하고 사용중</p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2040.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2041.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h1 id="amphetamine">💊 Amphetamine</h1> <ul> <li>Download</li> </ul> <p><a href="https://apps.apple.com/kr/app/amphetamine/id937984704?mt=12">https://apps.apple.com/kr/app/amphetamine/id937984704?mt=12</a></p> <ul> <li>Power Protect</li> </ul> <p><a href="https://x74353.github.io/Amphetamine-Power-Protect/">https://x74353.github.io/Amphetamine-Power-Protect/</a></p> <ul> <li>위 링크에서 Power Protect도 설치</li> <li>설치 후 암호 입력 없이 가능하도록 실행</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>pmset <span class="nt">-a</span> disablesleep 1
</code></pre></div></div> <ul> <li>비활성화한다면?</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>pmset <span class="nt">-a</span> disablesleep 0
</code></pre></div></div> <hr/> <h1 id="️monitorcontrol">🖥️ MonitorControl</h1> <p>외장모니터의 밝기를 편하게 컨트롤 하는 툴</p> <p>외장 모니터 안쓰면 설치할 필요 없음</p> <p>있으면 무조건 쓰는게 굿</p> <ul> <li>기존 모니터 설정→ 직접 컨트롤 불가능.</li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2042.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>직접 컨트롤 가능 + 키보드로도 가능</li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2043.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>Homebrew 통해 설치</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install</span> <span class="nt">--cask</span> monitorcontrol
</code></pre></div></div> <ul> <li> <p>웹으로 설치</p> <p><a href="https://github.com/MonitorControl/MonitorControl/releases">https://github.com/MonitorControl/MonitorControl/releases</a> 에서 최신버전 dmg 파일 다운로드</p> </li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2044.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2045.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h1 id="maccy">📎 Maccy</h1> <p>클립보드를 여러개 할 수 있고 저장시켜서 꺼내쓸 수 있는 도구다.</p> <p>막상 나는 잘 안쓴다.</p> <ul> <li>Homebrew로 설치</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install</span> <span class="nt">--cask</span> maccy
</code></pre></div></div> <p><a href="https://maccy.app/">https://maccy.app/</a></p> <p><a href="https://blog.naver.com/finway/223487330217">https://blog.naver.com/finway/223487330217</a></p> <hr/> <h1 id="top-notch-메뉴바-검은색으로">🎨 Top Notch (메뉴바 검은색으로)</h1> <p><a href="https://topnotch.app/">https://topnotch.app/</a></p> <p>무조건 메뉴바를 검정색으로 바꿔서 M자 탈모 모양을 없애주는 것</p> <p>원래 메뉴바 색은 배경화면에 맞게 설정되는데, 색이 맘에 안들면 검정색으로 바꿀 수 있다.</p> <p>단점 : 바꿔보니까 맥이 프로그램 끝을 둥글게 만들어서 작은 틈이 보여서 색이 바탕화면과 많이 차이나면 창을 최대화해도 틈이 살짝 보인다. <strong>생각보다 별로임</strong></p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2046.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <hr/> <h1 id="화면녹화시-소리-녹화-방법">🎥 화면녹화시 소리 녹화 방법</h1> <p>기본적으로 <code class="language-plaintext highlighter-rouge">cmd + shift + 5</code> 를 사용해서 녹화할 수 있는데, 소리 녹화가 동시에 안된다.</p> <p>Blackhole을 설치하면 소리도 동시에 녹화할 수 있다.</p> <p><strong>설치</strong></p> <p>2ch로도 충분하다는거 같음. (ch이 뭘 의미하는지 사실 잘 모름)</p> <p><strong>Option 1: Download Installer</strong></p> <ol> <li><a href="https://existential.audio/blackhole">Download the latest installer</a></li> <li>Donate 하지말고 I can’t afford to donate</li> <li>이메일 적고 대충 이름 적으면 이메일로 다운링크 줌</li> </ol> <p><strong>Option 2: Install via Homebrew</strong></p> <p>맥좀 써보고 컴공이라면 Homebrew 무조건 있을텐데 이걸로 깔면 바로 깔아짐</p> <ul> <li>2ch: <code class="language-plaintext highlighter-rouge">brew install blackhole-2ch</code></li> <li>16ch: <code class="language-plaintext highlighter-rouge">brew install blackhole-16ch</code></li> <li>64ch: <code class="language-plaintext highlighter-rouge">brew install blackhole-64ch</code></li> </ul> <p><strong>설정</strong></p> <ul> <li>오디오 MIDI 설정 → + 버튼 → 다중 출력 기기 생성</li> <li> <p>아래 사진과 같이 실제로 들을 오디오 기기와 BlackHole2ch을 체크</p> <p>(동시에 두 기기가 출력기기라는거임)</p> </li> <li>이름은 왼쪽에 있는 이름을 직접 클릭하면 바꿀 수 있음</li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2047.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>사용법</strong></p> <ul> <li>출력 (스피커) : [기존 스피커]+blackhole2ch</li> <li>입력 (마이크) : blackhole2ch</li> </ul> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2048.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2049.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>스피커에 blackhole이 있어서 내 컴퓨터 소리를 blackhole로 넘기고,</p> <p>마이크가 blackhole이라서 내 컴퓨터 소리가 녹화됨 !</p> <hr/> <h1 id="chrome-앱을-사용하자">Chrome 앱을 사용하자</h1> <p>대부분의 프로그램에서 웹 &gt; 앱 이다.</p> <p>대부분이 웹개발 먼저 이루어지고, 운영체제에 맞게 앱개발이 이루어지기 때문에, 웹이 더 클린한 경우가 많다.</p> <p>GPT는 특히 데스크탑 앱을 사용하면 표가 애매하게 잘리는 문제, 프로젝트에서 파일을 첨부하지 못하는 문제 등이 발생한다.</p> <p>하지만, 웹에서 쓰기에는 GPT만큼은 크롬에서 다른 탭이랑 같이 쓴는것 보다는 따로 창을 쓰는게 좋을 것 같기 때문에, 크롬에서 자체로 앱처럼 웹을 따로 만들어서 사용할 수 있다. (+ 난 인스타도 만들어놨다.)</p> <figure> <picture> <img src="/files/2025-04-13-mac-setting/image%2050.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><code class="language-plaintext highlighter-rouge">전송, 저장, 공유</code></p> <p><code class="language-plaintext highlighter-rouge">페이지를 앱으로 설치(…</code></p> <p>웹인데 따로 창을 앱처럼 사용하고, 깔끔하게 따로 빼서 사용할 수 있다.</p> <p>대부분의 기능에서 웹이 더 좋은 것 같다.</p> <hr/> <h1 id="whisky">🥃 Whisky</h1> <p>.exe 파일을 실행시킬 수 있는 도구다. 게임도 지원이된다. (안되는것도있음)</p> <p>다만, USB 연결은 안되는것같다.</p> <p><a href="https://getwhisky.app/ko/">https://getwhisky.app/ko/</a></p> <hr/> <h1 id="utm">💽 UTM</h1> <p>무료 가상머신이다. 대신 설치는 살짝 복잡하다. 굳이 안써도 됨. 용량 많이 차지</p> <p>추천 설정: 실제 메모리 크기와 CPU 코어 개수의 절반 이하로</p> <p><strong>Window 11</strong></p> <p>난 NFC RFID Reader가 .exe 파일인데, Whisky로는 USB 연결이 안되서 깔았다.</p> <p>USB연결도 물론 되고, 그냥 윈도우도 쓰는 느낌이다.</p> <p>램 8GB하고 싱글 카트라이더 돌려보니까 렉걸리더라</p> <p>유료보다는 렉걸리지만, 유료는 너무 비싼듯?</p> <p><a href="https://xanzhu.com/ko/blog/windows-on-apple-silicon">https://xanzhu.com/ko/blog/windows-on-apple-silicon</a></p> <p>다운르도 링크 (윈도우 10,11 둘다있는데 10은 자꾸 오류뜸)</p> <p><a href="https://mac.getutm.app/">https://mac.getutm.app/</a></p> <p><a href="https://apps.apple.com/us/app/crystalfetch-iso-downloader/id6454431289?mt=12">https://apps.apple.com/us/app/crystalfetch-iso-downloader/id6454431289?mt=12</a></p> <p><strong>Ubuntu</strong></p> <p>아래 링크에서 ARM 버전 다운로드</p> <p><a href="https://cdimage.ubuntu.com/releases/22.04/release/">https://cdimage.ubuntu.com/releases/22.04/release/</a></p> <p>참고 링크 :</p> <p><a href="https://solearn.tistory.com/275">https://solearn.tistory.com/275</a></p>]]></content><author><name></name></author><category term="Tip"/><summary type="html"><![CDATA[💡 MacBook Pro 14 inch M2 Pro (2023) Sequoia 15.3.1 Version 버전이 다르다면 다를 수 있음 어플 내 상세 설정은 내가 선호하는 대로 기록하려고 캡쳐해둠 어느정도 컴퓨터를 다룰 줄 아는 사람이라는 전제 하에 작성 (ex. Github 오픈소스니까 링크 들어가서 최신 버전 다운받기) Homebrew 등 다루는것도 있는데 궁금하면 알아서 GPT gogo]]></summary></entry><entry><title type="html">연구실 안전교육 스킵</title><link href="https://hoonably.github.io/blog/lab-safety/" rel="alternate" type="text/html" title="연구실 안전교육 스킵"/><published>2025-04-04T07:25:31+00:00</published><updated>2025-04-04T07:25:31+00:00</updated><id>https://hoonably.github.io/blog/lab-safety</id><content type="html" xml:base="https://hoonably.github.io/blog/lab-safety/"><![CDATA[<p>국가 돈낭비 중 하나인 연구실 안전교육을 아마 매학기 해야하는데 정말 귀찮다.</p> <p>특히 컴공은 정말 쓸데없는 듯 하다.</p> <p>알 사람은 알지만 스킵하는 방법이 있다.</p> <h3 id="1-동영상-틀기">1. 동영상 틀기</h3> <figure> <picture> <img src="/files/2025-04-04-lab-safety/image.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="2-개발자-모드-진입">2. 개발자 모드 진입</h3> <p>Window : <code class="language-plaintext highlighter-rouge">F12</code></p> <p>Mac : <code class="language-plaintext highlighter-rouge">cmd+opt+I</code></p> <h3 id="3-console-창-진입">3. Console 창 진입</h3> <figure> <picture> <img src="/files/2025-04-04-lab-safety/image%201.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>이제 Console 창에 다음 내용을 붙여넣기 하고 <code class="language-plaintext highlighter-rouge">Enter</code> 누르면 된다.</p> <ul> <li> <p>만약 Console에 붙여넣기가 불가능하다고 뜬다면?</p> <p>다음을 직접 영어로 입력 후 Enter</p> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nx">allow</span> <span class="nx">pasting</span>
</code></pre></div> </div> </li> </ul> <h3 id="4-1-progresscheck-바로-종료">4-1. ProgressCheck (바로 종료)</h3> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">progressCheck</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</code></pre></div></div> <h3 id="4-2-6000초-건너뛰기-바로-종료">4-2. 6000초 건너뛰기 (바로 종료)</h3> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">video</span><span class="dl">'</span><span class="p">).</span><span class="nx">currentTime</span><span class="o">+=</span><span class="mi">6000</span><span class="p">;</span>
</code></pre></div></div> <h3 id="4-3-16배속-위-건너뛰기-방법이-안된다면">4-3. 16배속 (위 건너뛰기 방법이 안된다면)</h3> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">document</span><span class="p">.</span><span class="nf">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">video</span><span class="dl">'</span><span class="p">).</span><span class="nx">playbackRate</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
</code></pre></div></div> <h3 id="5-퀴즈-정답">5. 퀴즈 정답</h3> <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
<span class="nx">answer</span> <span class="o">=</span> <span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#qustionCorrectNo_</span><span class="dl">"</span> <span class="o">+</span> <span class="nx">i</span><span class="p">).</span><span class="nf">val</span><span class="p">();</span>
<span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">input[name='qustionAnswerList[</span><span class="dl">"</span><span class="o">+</span><span class="nx">i</span><span class="o">+</span><span class="dl">"</span><span class="s2">].Answer']:radio[value=</span><span class="dl">"</span><span class="o">+</span><span class="nx">answer</span><span class="o">+</span><span class="dl">"</span><span class="s2">]</span><span class="dl">"</span><span class="p">).</span><span class="nf">attr</span><span class="p">(</span><span class="dl">"</span><span class="s2">checked</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <figure> <picture> <img src="/files/2025-04-04-lab-safety/image%202.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-04-lab-safety/image%203.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-04-04-lab-safety/image%204.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure>]]></content><author><name></name></author><category term="Tip"/><summary type="html"><![CDATA[국가 돈낭비 중 하나인 연구실 안전교육을 아마 매학기 해야하는데 정말 귀찮다.]]></summary></entry><entry><title type="html">Pintos Setting</title><link href="https://hoonably.github.io/blog/pintos-setting/" rel="alternate" type="text/html" title="Pintos Setting"/><published>2025-03-20T07:26:04+00:00</published><updated>2025-03-20T07:26:04+00:00</updated><id>https://hoonably.github.io/blog/pintos-setting</id><content type="html" xml:base="https://hoonably.github.io/blog/pintos-setting/"><![CDATA[<p>메모: docker start -ai pintos</p> <blockquote> <p>Welcome to Pintos. Pintos is a simple operating system framework for the 80x86 architecture.</p> </blockquote> <h1 id="docker-build">Docker Build</h1> <p><a href="https://github.com/NamJeongseok/PintOS-Docker-UNIST">https://github.com/NamJeongseok/PintOS-Docker-UNIST</a></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM ubuntu:12.04

RUN <span class="nb">sed</span> <span class="nt">-i</span> <span class="nt">-e</span> <span class="s1">'s/archive.ubuntu.com/old-releases.ubuntu.com/g'</span> /etc/apt/sources.list
RUN <span class="nb">sed</span> <span class="nt">-i</span> <span class="nt">-e</span> <span class="s1">'s/security.ubuntu.com/old-releases.ubuntu.com/g'</span> /etc/apt/sources.list

RUN apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\</span>
	bash <span class="se">\</span>
	vim <span class="se">\</span>
	build-essential <span class="se">\</span>
	gcc-4.4 <span class="se">\</span>
	gcc-multilib <span class="se">\</span>
	g++-4.4 <span class="se">\</span>
	perl <span class="se">\</span>
	wget <span class="se">\</span>
	patch <span class="se">\</span>
	libncurses5-dev <span class="se">\</span>
	libx11-dev libxrandr-dev xorg-dev <span class="se">\</span>
	make

RUN <span class="nb">mv</span> /usr/bin/gcc-4.4 /usr/bin/gcc
RUN <span class="nb">mv</span> /usr/bin/g++-4.4 /usr/bin/g++
COPY ./bochs-2.2.6.tar.gz /root/
RUN <span class="nb">mkdir</span> /root/pintos 
RUN <span class="nb">echo</span> <span class="s1">'export PATH="$PATH:/root/pintos/src/utils"'</span> <span class="o">&gt;&gt;</span> ~/.bashrc

CMD <span class="o">[</span><span class="s2">"/bin/bash"</span><span class="o">]</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone git@github.com:NamJeongseok/PintOS-Docker-UNIST.git
<span class="nb">cd </span>PintOS-Docker-UNIST
</code></pre></div></div> <ul> <li>amd64 (x86_64) (Window)</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>docker build <span class="nt">-t</span> pintos <span class="nb">.</span>
</code></pre></div></div> <ul> <li>ARM64 (Silicon Mac)</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">--platform</span><span class="o">=</span>linux/amd64 <span class="nt">-t</span> pintos <span class="nb">.</span>
</code></pre></div></div> <h1 id="error">Error</h1> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>➜  PintOS-Docker-UNIST git:<span class="o">(</span>main<span class="o">)</span> <span class="nb">sudo </span>docker build <span class="nt">-t</span> pintos <span class="nb">.</span>                  
Password:
<span class="o">[</span>+] Building 1.8s <span class="o">(</span>9/14<span class="o">)</span>                                                          docker:desktop-linux
 <span class="o">=&gt;</span> <span class="o">[</span>internal] load build definition from Dockerfile                                              0.0s
 <span class="o">=&gt;</span> <span class="o">=&gt;</span> transferring dockerfile: 696B                                                              0.0s
 <span class="o">=&gt;</span> <span class="o">[</span>internal] load metadata <span class="k">for </span>docker.io/library/ubuntu:12.04                                   1.5s
 <span class="o">=&gt;</span> <span class="o">[</span>auth] library/ubuntu:pull token <span class="k">for </span>registry-1.docker.io                                     0.0s
 <span class="o">=&gt;</span> <span class="o">[</span>internal] load .dockerignore                                                                 0.0s
 <span class="o">=&gt;</span> <span class="o">=&gt;</span> transferring context: 2B                                                                   0.0s
 <span class="o">=&gt;</span> <span class="o">[</span>1/9] FROM docker.io/library/ubuntu:12.04@sha256:18305429afa14ea462f810146ba44d4363ae76e4c8d  0.0s
 <span class="o">=&gt;</span> <span class="o">=&gt;</span> resolve docker.io/library/ubuntu:12.04@sha256:18305429afa14ea462f810146ba44d4363ae76e4c8d  0.0s
 <span class="o">=&gt;</span> <span class="o">[</span>internal] load build context                                                                 0.0s
 <span class="o">=&gt;</span> <span class="o">=&gt;</span> transferring context: 42B                                                                  0.0s
 <span class="o">=&gt;</span> CACHED <span class="o">[</span>2/9] RUN <span class="nb">sed</span> <span class="nt">-i</span> <span class="nt">-e</span> <span class="s1">'s/archive.ubuntu.com/old-releases.ubuntu.com/g'</span> /etc/apt/sources  0.0s
 <span class="o">=&gt;</span> CACHED <span class="o">[</span>3/9] RUN <span class="nb">sed</span> <span class="nt">-i</span> <span class="nt">-e</span> <span class="s1">'s/security.ubuntu.com/old-releases.ubuntu.com/g'</span> /etc/apt/source  0.0s
 <span class="o">=&gt;</span> ERROR <span class="o">[</span>4/9] RUN apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span>  bash  vim  build-essential  gcc-4.4  g  0.2s
<span class="nt">------</span>                                                                                                 
 <span class="o">&gt;</span> <span class="o">[</span>4/9] RUN apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> 	bash 	vim 	build-essential 	gcc-4.4 	gcc-multilib 	g++-4.4 	perl 	wget 	patch 	libncurses5-dev 	libx11-dev libxrandr-dev xorg-dev 	make:
0.202 qemu: uncaught target signal 11 <span class="o">(</span>Segmentation fault<span class="o">)</span> - core dumped
0.206 E: Method http has died unexpectedly!
0.207 E: Sub-process http received a segmentation fault.
<span class="nt">------</span>

 1 warning found <span class="o">(</span>use docker <span class="nt">--debug</span> to <span class="nb">expand</span><span class="o">)</span>:
 - InvalidBaseImagePlatform: Base image ubuntu:12.04 was pulled with platform <span class="s2">"linux/amd64"</span>, expected <span class="s2">"linux/arm64"</span> <span class="k">for </span>current build <span class="o">(</span>line 1<span class="o">)</span>
Dockerfile:6
<span class="nt">--------------------</span>
   5 |     
   6 | <span class="o">&gt;&gt;&gt;</span> RUN apt-get update <span class="o">&amp;&amp;</span> apt-get <span class="nb">install</span> <span class="nt">-y</span> <span class="se">\</span>
   7 | <span class="o">&gt;&gt;&gt;</span> 	bash <span class="se">\</span>
   8 | <span class="o">&gt;&gt;&gt;</span> 	vim <span class="se">\</span>
   9 | <span class="o">&gt;&gt;&gt;</span> 	build-essential <span class="se">\</span>
  10 | <span class="o">&gt;&gt;&gt;</span> 	gcc-4.4 <span class="se">\</span>
  11 | <span class="o">&gt;&gt;&gt;</span> 	gcc-multilib <span class="se">\</span>
  12 | <span class="o">&gt;&gt;&gt;</span> 	g++-4.4 <span class="se">\</span>
  13 | <span class="o">&gt;&gt;&gt;</span> 	perl <span class="se">\</span>
  14 | <span class="o">&gt;&gt;&gt;</span> 	wget <span class="se">\</span>
  15 | <span class="o">&gt;&gt;&gt;</span> 	patch <span class="se">\</span>
  16 | <span class="o">&gt;&gt;&gt;</span> 	libncurses5-dev <span class="se">\</span>
  17 | <span class="o">&gt;&gt;&gt;</span> 	libx11-dev libxrandr-dev xorg-dev <span class="se">\</span>
  18 | <span class="o">&gt;&gt;&gt;</span> 	make
  19 |     
<span class="nt">--------------------</span>
ERROR: failed to solve: process <span class="s2">"/bin/sh -c apt-get update &amp;&amp; apt-get install -y </span><span class="se">\t</span><span class="s2">bash </span><span class="se">\t</span><span class="s2">vim </span><span class="se">\t</span><span class="s2">build-essential </span><span class="se">\t</span><span class="s2">gcc-4.4 </span><span class="se">\t</span><span class="s2">gcc-multilib </span><span class="se">\t</span><span class="s2">g++-4.4 </span><span class="se">\t</span><span class="s2">perl </span><span class="se">\t</span><span class="s2">wget </span><span class="se">\t</span><span class="s2">patch </span><span class="se">\t</span><span class="s2">libncurses5-dev </span><span class="se">\t</span><span class="s2">libx11-dev libxrandr-dev xorg-dev </span><span class="se">\t</span><span class="s2">make"</span> did not <span class="nb">complete </span>successfully: <span class="nb">exit </span>code: 100

View build details: docker-desktop://dashboard/build/desktop-linux/desktop-linux/307xpyqphklv4cd5fc8tmb1eg
</code></pre></div></div> <h3 id="rosetta-키기">Rosetta 키기</h3> <p>내가 전에 핀토스 미리 해보려고 블로그 찾아보다가 이 설정을 꺼야 x86으로 확실하게 돌아간다고 해서 꺼놨었는데, 이거 키니까 잘 된다.</p> <figure> <picture> <img src="/files/2025-03-20-pintos-setting/image.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>이전에 핀토스 미리 해보려고 할때, 어떤 블로그 보고</p> <p>저걸 꺼야 x86으로 정확히 작동한다고 해서 꺼놨었는데, 이게 문제였다.</p> <blockquote> <p>Docker에서는 <code class="language-plaintext highlighter-rouge">--platform=linux/amd64</code> 옵션으로 x86 이미지를 실행할 때, 내부적으로 QEMU를 이용해 에뮬레이션함.</p> <p>이때 Rosetta를 활성화하면 QEMU가 더 안정적이고 빠르게 동작함. 특히 오래된 리눅스 이미지(Ubuntu 12.04 같은 거)에서 apt-get이 죽거나 세그폴트 나는 경우, 대부분 Rosetta 꺼져 있어서 생기는 문제임.</p> </blockquote> <h3 id="빌드-성공">빌드 성공</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">--platform</span><span class="o">=</span>linux/amd64 <span class="nt">-t</span> pintos <span class="nb">.</span>
</code></pre></div></div> <figure> <picture> <img src="/files/2025-03-20-pintos-setting/image%201.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h1 id="start">Start</h1> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget <span class="o">[</span>http://www.stanford.edu/class/cs140/projects/pintos/pintos.tar.gz]<span class="o">(</span>http://www.stanford.edu/class/cs140/projects/pintos/pintos.tar.gz<span class="o">)</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar </span>xvf pintos.tar.
</code></pre></div></div> <h3 id="파일-권한-에러-해결">파일 권한 에러 해결</h3> <p>진짜 이거때문에 개고생했음…</p> <p>Stanford에서 받은 파일이 권한이 없는 채로 주는데,</p> <p>윈도우에서는 원래 상관이 없어서 괜찮은데,</p> <p>맥에서는 실행 불가능한채로 압축이 풀어져서 문제가 발생함.</p> <p>근데 이게 또 이 상태로 Docker로 옮겨서 그냥 Permission Denied 해버리니까</p> <p>이게 도대체 왜 그런지 GPT 써도 잘 몰랐음.</p> <p>Docker 넘어가기 전부터 원본 파일 권한이 부족해서 그런건데 Docker 파일 공유 방식때문인줄알고 삽질함</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xattr <span class="nt">-rc</span> pintos/
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">chmod</span> <span class="nt">-R</span> u+rwX,go+rX pintos/
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find pintos/ <span class="nt">-type</span> f <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-l</span> <span class="o">{}</span> <span class="se">\;</span>
</code></pre></div></div> <p>위 명령어 하면 아래처럼 file permission이 뜸</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-rw-r--r--</span>@ 1 hoon  staff  333  9 27  2012 pintos//src/Makefile.kernel
<span class="nt">-rwxr-xr-x</span>@ 1 hoon  staff  1486  9 27  2012 pintos//src/misc/bochs-2.2.6-build.sh
<span class="nt">-rw-r--r--</span>@ 1 hoon  staff  511  9 27  2012 pintos//src/misc/bochs-2.2.6-solaris-link.patch
</code></pre></div></div> <p>여기 보면 실행 가능한 파일 (.sh) 파일 등에 x 표시가 생길것임.</p> <p>또는 실행 가능한 파일만 권한 보려면</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>find pintos/ <span class="nt">-type</span> f <span class="nt">-perm</span> <span class="nt">-111</span> <span class="nt">-exec</span> <span class="nb">ls</span> <span class="nt">-l</span> <span class="o">{}</span> <span class="se">\;</span>
</code></pre></div></div> <p>아래처럼 됐다면 성공</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-rwxr-xr-x</span>@ 1 hoon  staff  1486  9 27  2012 pintos//src/misc/bochs-2.2.6-build.sh
<span class="nt">-rwxr-xr-x</span>@ 1 hoon  staff  4096  9 27  2012 pintos//src/tests/make-grade
<span class="nt">-rwxr-xr-x</span>@ 1 hoon  staff  2951  9 27  2012 pintos//src/utils/backtrace
<span class="nt">-rwxr-xr-x</span>@ 1 hoon  staff  4563  9 27  2012 pintos//src/utils/pintos-mkdisk
<span class="nt">-rwxr-xr-x</span>@ 1 hoon  staff  429  9 27  2012 pintos//src/utils/pintos-gdb
<span class="nt">-rwxr-xr-x</span>@ 1 hoon  staff  29821  9 27  2012 pintos//src/utils/pintos
</code></pre></div></div> <h3 id="컨테이너-들어가기-전에-로컬에서-편하게-bochs-파일-수정">컨테이너 들어가기 전에 로컬에서 편하게 <code class="language-plaintext highlighter-rouge">bochs</code> 파일 수정</h3> <p><code class="language-plaintext highlighter-rouge">pintos/src/misc/bochs-2.2.6-build.sh</code></p> <figure> <picture> <img src="/files/2025-03-20-pintos-setting/image%202.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>다음 내용으로 수정</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFGOPTS</span><span class="o">=</span><span class="s2">"--enable-cpu-level=6 --with-x --with-x11 --with-term --with-nogui --prefix=</span><span class="nv">$DSTDIR</span><span class="s2">"</span>
</code></pre></div></div> <h1 id="docker-run">docker run</h1> <p>드디어 제대로 실행해보자.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--platform</span><span class="o">=</span>linux/amd64 <span class="nt">-it</span> <span class="nt">-p</span> 80:80 <span class="se">\</span>
	<span class="nt">-v</span> /Users/hoon/github/os20201118_20201032/pintos:/root/pintos <span class="se">\</span>
	<span class="nt">--name</span> pintos pintos
</code></pre></div></div> <h1 id="boch-266-설치">boch 2.6.6 설치</h1> <ul> <li> <p>위에서 VSCode로 bochs 수정 안했다면</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">cd </span>pintos/src/misc
</code></pre></div> </div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  vi bochs-2.2.6-build.sh
</code></pre></div> </div> <blockquote> <p>i : 수정 모드 수정… ESC : 수정 모드 나가기 :wq : 저장 후 종료</p> <ul> <li>다음 내용으로 수정</li> </ul> </blockquote> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nv">CFGOPTS</span><span class="o">=</span><span class="s2">"--enable-cpu-level=6 --with-x --with-x11 --with-term --with-nogui --prefix=</span><span class="nv">$DSTDIR</span><span class="s2">"</span>
</code></pre></div> </div> </li> </ul> <blockquote class="block-warning"> <p>📢</p> <p>만약 Container를 삭제해서 다시 Run한다면 이 과정을 다시 해줘야한다.</p> </blockquote> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /root/pintos/src/misc
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">env </span><span class="nv">SRCDIR</span><span class="o">=</span>/root/ <span class="nv">PINTOSDIR</span><span class="o">=</span>/root/pintos/ <span class="nv">DSTDIR</span><span class="o">=</span>/usr/local ./bochs-2.2.6-build.sh
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>which bochs
bochs <span class="nt">-v</span>
</code></pre></div></div> <h1 id="test">Test</h1> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /root/pintos/src/threads
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>build
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pintos <span class="nt">-q</span> run alarm-multiple
</code></pre></div></div> <figure> <picture> <img src="/files/2025-03-20-pintos-setting/image%203.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h1 id="github-repo-생성">github repo 생성</h1> <p><a href="https://github.com/hoonably/os20201118_20201032">[https://github.com/hoonably/os20201118_20201032](https://github.com/hoonably/os20201118_20201032)</a></p> <h1 id="rootpintossrc-에서-시작하기">root/pintos/src 에서 시작하기</h1> <p>할때마다 root 폴더에서 시작하는방법</p> <p>한번 쳐주면 항상 적용됨.</p> <p>도커파일에 다음 줄을 넣어도 되긴 함.</p> <div class="language-docker highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">WORKDIR</span><span class="s"> /root/pintos/src</span>
</code></pre></div></div> <p>근데 이미 빌드했으니 아래 명령어를 컨테이너 내부에서 치면 됨</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s1">'cd /root/pintos/src'</span> <span class="o">&gt;&gt;</span> ~/.bashrc
</code></pre></div></div> <ul> <li> <p>이후 bashrc 상황</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">cat</span> ~/.bashrc
</code></pre></div> </div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ... 맨 아래줄에 다음 두줄이 있으면 성공
  <span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PATH</span><span class="s2">:/root/pintos/src/utils"</span>
  <span class="nb">cd</span> /root/pintos/src
    
</code></pre></div> </div> </li> </ul> <h1 id="한번-run-이후-container-시작">한번 Run 이후 Container 시작</h1> <figure> <picture> <img src="/files/2025-03-20-pintos-setting/image%204.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>컨테이너에서 <code class="language-plaintext highlighter-rouge">exit</code> 를 했다면,</p> <p>위처럼 Container는 남아있고, 중지되어있을 것이다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker start <span class="nt">-ai</span> pintos
</code></pre></div></div> <p>나중에 또 같은 방식으로 <code class="language-plaintext highlighter-rouge">exit</code> 하고 반복하면 된다.</p> <h1 id="branch">Branch</h1> <h2 id="브랜치-생성">브랜치 생성</h2> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">-b</span> <span class="o">[</span>your-branch-name]
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout <span class="nt">-b</span> feat/alarm-clock
</code></pre></div></div> <hr/> <h3 id="-만든-브랜치를-github에-푸시">📤 만든 브랜치를 GitHub에 푸시</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push <span class="nt">-u</span> origin <span class="o">[</span>your-branch-name]
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git push <span class="nt">-u</span> origin feat/alarm-clock
</code></pre></div></div> <ul> <li><code class="language-plaintext highlighter-rouge">u</code> 옵션은 이후 <code class="language-plaintext highlighter-rouge">git push</code>/<code class="language-plaintext highlighter-rouge">pull</code> 시 브랜치 이름 생략 가능하게 연결해줌</li> <li> <p>다음부터 그냥 push 해도 됨.</p> </li> <li> <p>왜 <code class="language-plaintext highlighter-rouge">feat/</code> 를 쓰는가?</p> <p>✅ 브랜치 이름 패턴</p> <table> <thead> <tr> <th>Prefix</th> <th>의미</th> <th>예시 브랜치명</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">feat/</code></td> <td>새로운 기능 추가</td> <td><code class="language-plaintext highlighter-rouge">feat/alarm-clock</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">fix/</code></td> <td>버그 수정</td> <td><code class="language-plaintext highlighter-rouge">fix/overflow-bug</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">refactor/</code></td> <td>코드 리팩토링 (기능 변화 X)</td> <td><code class="language-plaintext highlighter-rouge">refactor/thread-init</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">test/</code></td> <td>테스트 코드 추가/수정</td> <td><code class="language-plaintext highlighter-rouge">test/userprog-tests</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">doc/</code></td> <td>문서, README 수정</td> <td><code class="language-plaintext highlighter-rouge">doc/setup-instructions</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">chore/</code></td> <td>빌드, 설정 변경 등 잡일</td> <td><code class="language-plaintext highlighter-rouge">chore/dockerfile-update</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">hotfix/</code></td> <td>급한 버그 수정 (배포 후)</td> <td><code class="language-plaintext highlighter-rouge">hotfix/build-crash</code></td> </tr> </tbody> </table> <hr/> <p>✅ 왜 이렇게 쓰나?</p> <ul> <li>협업 중에 브랜치가 많아질 때 → <strong>이름만 보고 용도 파악 가능</strong></li> <li>GitHub Pull Request에서 <strong>자동 정렬이나 필터도 편리함</strong></li> <li>팀 내부에서 <strong>일관된 스타일 유지 가능</strong></li> <li>일부 자동화 도구(CI/CD, Release notes)와도 잘 호환됨</li> </ul> </li> <li>VSCode에서 한다면 이렇게 커밋 어디에 하는건지 확인해 볼 수 있음</li> </ul> <figure> <picture> <img src="/files/2025-03-20-pintos-setting/image%205.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h1 id="github-pull-이후-error">Github Pull 이후 Error</h1> <p>이건 맥에서 발생한 것은 아니고, 팀원 윈도우에서 git pull 해온 후 .sh 파일을 실행했을 때 나는 문제다.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@04fedab3f530:~/pintos/src/misc# <span class="nb">env </span><span class="nv">SRCDIR</span><span class="o">=</span>/root/ <span class="nv">PINTOSDIR</span><span class="o">=</span>/root/pintos/ <span class="nv">DSTDIR</span><span class="o">=</span>/usr/local bash ./bochs-2.2.6-build.sh

./bochs-2.2.6-build.sh: line 2: <span class="s1">$'</span><span class="se">\r</span><span class="s1">'</span>: <span class="nb">command </span>not found
./bochs-2.2.6-build.sh: line 41: syntax error: unexpected end of file
</code></pre></div></div> <ol> <li> <p><strong><code class="language-plaintext highlighter-rouge">$'\r': command not found</code></strong></p> <p>이 메시지는 파일이 <strong>Windows 스타일 줄바꿈 (CRLF)</strong> 으로 저장되어 있어서 발생하는 것입니다. 유닉스/리눅스에서는 <strong>LF (\n)</strong> 줄바꿈만 사용해야 하므로, 이 스크립트는 리눅스에서 직접 실행되기 전에 포맷을 변환해야 합니다.</p> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">syntax error: unexpected end of file</code></strong></p> <p>줄바꿈 문제로 인해 쉘이 스크립트의 구조를 제대로 해석하지 못해 끝부분에서 문법 오류가 발생한 것입니다.</p> </li> </ol> <ul> <li>윈도우에서 git을 설치하면 기본적으로 다음 설정인데, 이게 문제다.</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>core.autocrlf<span class="o">=</span><span class="nb">true</span>
</code></pre></div></div> <p>이 설정은:</p> <ul> <li><strong>clone/pull 할 때 → CRLF로 변환</strong></li> <li>commit/push 할 때 → LF로 되돌림</li> </ul> <p>즉, 친구가 pull할 때 <code class="language-plaintext highlighter-rouge">.sh</code> 파일이 CRLF로 바뀌어버린 것이다.</p> <p>Docker 우분투 컨테이너는 리눅스니까 CRLF 해석 못 함 → 에러 발생</p> <h3 id="해결방법-️">해결방법 ⭐️</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config <span class="nt">--global</span> core.autocrlf  <span class="c"># 현재 설정 확인</span>
</code></pre></div></div> <table> <thead> <tr> <th>결과</th> <th>의미</th> <th> </th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">true</code></td> <td>윈도우용: pull할 때 CRLF, push할 때 LF</td> <td> </td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">input</code></td> <td>맥/리눅스용: pull할 때 LF 유지, push할 때 LF</td> <td> </td> </tr> <tr> <td>(아무것도 없음)</td> <td>기본값 사용 중 (보통 OS에 따라 다르게 작동)</td> <td><br/>- <code class="language-plaintext highlighter-rouge">input</code> 으로 변경하기</td> </tr> </tbody> </table> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config <span class="nt">--global</span> core.autocrlf input
</code></pre></div></div> <h3 id="이미-받은-파일-고치기">이미 받은 파일 고치기</h3> <p>그냥 직접 줄바꿈 스타일을 바꿔주는거다.</p> <p>근데 .sh파일 다른것도 많고 이건 그냥 임시방편이니 다시 pull하는걸 추천.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'s/\r$//'</span> bochs-2.2.6-build.sh
</code></pre></div></div> <h1 id="ff">FF?</h1> <p>VSCode로 보면 다음과 같이 FF가 들어간 신기한 문자가 있다.</p> <figure> <picture> <img src="/files/2025-03-20-pintos-setting/image%206.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>이 <code class="language-plaintext highlighter-rouge">FF</code>는 <strong>Form Feed (줄 바꿈 명령 중 하나)</strong></p> <p>ASCII 코드로는 <code class="language-plaintext highlighter-rouge">0x0C</code> (또는 <code class="language-plaintext highlighter-rouge">^L</code>) 이고,</p> <p>터미널에서는 <strong>페이지 넘김</strong> 역할을 하던 예전 문자</p> <hr/> <ul> <li>예전 교재/에디터에서 복붙한 코드</li> <li>누군가 <code class="language-plaintext highlighter-rouge">.c</code> 파일에 <code class="language-plaintext highlighter-rouge">^L</code> 넣어서 구분자처럼 쓰던 습관</li> <li>핀토스나 오래된 유닉스 기반 코드에서 가끔 보임.</li> <li>VS Code가 특별히 보여주는 거고, <strong>오류는 아님</strong></li> </ul>]]></content><author><name></name></author><category term="Study"/><category term="CS"/><summary type="html"><![CDATA[메모: docker start -ai pintos]]></summary></entry><entry><title type="html">SVDQuant: Absorbing Outliers by Low-Rank Components for 4-Bit Diffusion Models</title><link href="https://hoonably.github.io/blog/svdquant/" rel="alternate" type="text/html" title="SVDQuant: Absorbing Outliers by Low-Rank Components for 4-Bit Diffusion Models"/><published>2025-03-06T07:25:10+00:00</published><updated>2025-03-06T07:25:10+00:00</updated><id>https://hoonably.github.io/blog/svdquant</id><content type="html" xml:base="https://hoonably.github.io/blog/svdquant/"><![CDATA[<p>Authors: Muyang Li<em>, Yujun Lin</em>, Zhekai Zhang*, Tianle Cai, Xiuyu Li, Junxian Guo, Enze Xie, Chenlin Meng, Jun-Yan Zhu, Song Han MIT, NVIDIA, CMU, Princeton, UC Berkeley, SJTU, Pika Labs Venue &amp; Year: 25, ICLR, Spotlight 날짜: 2025년 3월 6일</p> <table> <thead> <tr> <th>ArXiv</th> <th><a href="https://arxiv.org/abs/2411.05007">https://arxiv.org/abs/2411.05007</a></th> </tr> </thead> <tbody> <tr> <td>Project Page</td> <td><a href="https://hanlab.mit.edu/projects/svdquant">https://hanlab.mit.edu/projects/svdquant</a></td> </tr> <tr> <td>Github Code</td> <td><a href="https://github.com/mit-han-lab/nunchaku">https://github.com/mit-han-lab/nunchaku</a></td> </tr> <tr> <td>Demo</td> <td><a href="https://svdquant.mit.edu/">https://svdquant.mit.edu/</a></td> </tr> </tbody> </table> <blockquote class="block-warning"> <p>💡</p> <p><strong>Key Differentiator</strong></p> <p>“Outlier Absorption Using Singular Value Decomposition”</p> </blockquote> <figure> <picture> <img src="/files/2025-03-06-svdquant/image.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h1 id="song-han">Song Han?</h1> <blockquote> <p>Song Han is an associate professor at MIT EECS. He earned his PhD from Stanford, pioneering efficient AI computing techniques such as “Deep Compression” (pruning, quantization) and the “Efficient Inference Engine,” which first introduced weight sparsity to modern AI chips, making it one of the top-5 most cited papers in the 50-year history of ISCA (1953-2023). His innovations, including TinyML and hardware-aware neural architecture search (Once-for-All Network), have advanced AI model deployment on resource-constrained devices.</p> </blockquote> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%201.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h1 id="1-introduction">1. Introduction</h1> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%202.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>LLM과 비교했을 때, 모델 사이즈에 따라 계산 비용이 빠르게 증가한다.</p> <p>Moore’s law가 slow down 함으로서, 저렴한 추론(low-precision inference) 으로 전환하는중</p> <p>→ 4bit floating point (FP4)가 대세임</p> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%203.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>LLM</p> <p>latency는 주로 가중치(weight) 로딩 속도에 의해 결정</p> <p>“가중치만 양자화(weight-only quantization)” 해도 속도를 개선</p> <p>Diffusion 모델</p> <p>레이턴시는 가중치를 불러오는 속도가 아니라, 연산량 자체가 병목</p> <p>왜냐하면 가중치만 4비트로 줄여도 활성화값이 16비트이면, 연산 과정에서 16비트로 다시 변환(upcast)되므로 연산량이 줄어들지 않음.</p> <p>결국 연산량을 줄이려면 가중치(weight)뿐만 아니라 <strong>활성화값(activation)</strong>도 함께 4비트로 양자화해야 함.</p> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%204.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <blockquote class="block-warning"> <p>📢</p> <ul> <li><strong>Input Channel</strong> → 원래 Activation에서 나온 입력 채널</li> <li><strong>Channel</strong> → Weight의 각 채널</li> </ul> </blockquote> <h3 id="1-기존-4비트-양자화4-bit-quantization의-문제점">1. 기존 4비트 양자화(4-bit Quantization)의 문제점</h3> <ul> <li>가중치(Weight)와 활성화값(Activation) 모두 4비트로 줄이면 품질이 크게 저하될 가능성이 높음.</li> <li>특히 기존 방법(예: Smoothing)은 가중치와 활성화값 사이에서 Outlier를 이동시키는 방식을 사용했지만,Diffusion 모델에서는 Outlier가 양쪽(W, X) 모두에서 심각하게 발생하므로 효과적이지 않음. <ul> <li>기존 방식은 활성화값(X)에서 Outlier를 제거하려고 하면 가중치(W)로 이동하고, 반대로 하면 X에 Outlier가 남는 문제 발생.</li> </ul> </li> </ul> <h3 id="2-svdquant의-핵심-아이디어">2. SVDQuant의 핵심 아이디어</h3> <p>✅ Outlier를 단순히 이동하는 것이 아니라, “<strong>흡수</strong>“하는 방법을 사용함.</p> <p>✅ 저비용의 “Low-Rank Branch”를 추가하여 Outlier를 가중치(W)에서 흡수함.</p> <p>✅ 이를 위해 SVD(Singular Value Decomposition, 특이값 분해) 기법을 활용하여 가중치를 두 개의 성분으로 분해함.</p> <h3 id="3-svdquant의-단계별-동작-방식">3. SVDQuant의 단계별 동작 방식</h3> <p>1️⃣ Outlier 이동 (Smoothing)</p> <ul> <li>먼저 Outlier를 활성화값(X)에서 가중치(W)로 이동함.</li> <li>이를 통해 활성화값(X)이 더 균일해져서 4비트 양자화가 더 쉬워짐.</li> </ul> <p>2️⃣ SVD(특이값 분해)를 적용하여 가중치(W)를 두 개의 성분으로 분해</p> <ul> <li>W → L1L2(저순위 성분) + 잔여 성분(W - L1L2)로 분리</li> <li>L1L2(저순위 성분)은 16비트로 유지하고, W - L1L2(잔여 성분)만 4비트로 양자화</li> <li>즉, 저순위 성분(Low-Rank Component)이 Outlier를 흡수하면서 4비트 양자화가 더 쉬워짐.</li> </ul> <p>3️⃣ 저순위 성분을 따로 계산하면 메모리 액세스 오버헤드가 증가하는 문제 발생</p> <ul> <li>즉, L1L2를 별도로 처리하면 연산 속도가 느려지는 문제가 생김.</li> <li>기본적으로 4비트 연산의 속도를 높이려고 했는데, 저순위 연산이 추가되면 오히려 느려질 수 있음.</li> </ul> <p>4️⃣ 이를 해결하기 위해 전용 추론 엔진(Nunchaku) 설계</p> <ul> <li>Nunchaku 엔진은 4비트 양자화 연산과 저순위 연산을 함께 최적화하여 오버헤드를 줄임.</li> <li>즉, L1L2(저순위 연산)와 4비트 연산을 함께 처리하는 커널(fusion kernel)로 변환하여 성능을 최적화.</li> <li>이를 통해 추가적인 연산량이 생기더라도 실제로는 4비트 연산의 속도를 향상할 수 있도록 설계됨.</li> </ul> <h3 id="기존-방식smoothquant-awq과-svdquant의-차이"><strong>기존 방식(SmoothQuant, AWQ)과 SVDQuant의 차이</strong></h3> <table> <thead> <tr> <th>방법</th> <th>방식</th> <th>Outlier 처리 방식</th> <th>적용 대상</th> <th>문제점</th> </tr> </thead> <tbody> <tr> <td><strong>SmoothQuant (2023)</strong></td> <td>W4A4</td> <td>Input Channel(Activation) → Channel(Weight)</td> <td>LLM(대형 언어 모델)</td> <td>Outlier가 가중치에 누적됨</td> </tr> <tr> <td><strong>AWQ (2024)</strong></td> <td>W4A4</td> <td><strong>가중치 중 중요한 부분을 보존하여 양자화</strong></td> <td>LLM</td> <td>Diffusion 모델에서는 한계 가능성</td> </tr> <tr> <td><strong>SVDQuant (2024)</strong></td> <td>W4A4</td> <td><strong>저순위(Low-Rank) 성분으로 Outlier 흡수</strong></td> <td>Diffusion 모델 최적화</td> <td>추가 연산을 해결해야 함</td> </tr> </tbody> </table> <h3 id="1-smoothquant-2023--activation에서-weight로-이상치-이동"><strong>1. SmoothQuant (2023) – Activation에서 Weight로 이상치 이동</strong></h3> <p>SmoothQuant의 핵심 아이디어는 <strong>활성화값(Activation)에서 발생하는 이상치를 가중치(Weight)로 이동</strong>시키는 거야​Li 등 - 2024 - SVDQuan….</p> <ul> <li><strong>기존 문제</strong> <ul> <li>Transformer 기반 모델에서 Self-Attention 연산이 많아서 <strong>활성화값(Activation)의 범위가 넓어지고 이상치가 발생</strong>하는 경우가 많아.</li> <li>이를 8-bit이나 4-bit로 양자화하면, 작은 값들은 모두 0이 되고, 정보 손실이 심해짐.</li> </ul> </li> <li><strong>해결 방법</strong> <ul> <li>활성화값(Activation)의 채널별 스케일링을 적용하여, <strong>이상치를 가중치(Weight) 쪽으로 이동</strong>시킴.</li> <li>즉, 원래 Activation 값이 크면, 해당 채널을 스케일링해서 줄이고, 대신 그 값을 Weight에서 보상해주는 방식.</li> <li>이렇게 하면, <strong>Activation 값이 양자화할 때 손실 없이 더 균등하게 분포할 수 있음</strong>.</li> </ul> </li> <li><strong>한계</strong> <ul> <li>Weight 쪽으로 이상치를 몰아넣으면, <strong>Weight의 값이 커지고, Weight 양자화 시 오류가 커질 가능성</strong>이 있음.</li> <li>따라서 <strong>Weight를 4-bit로 양자화할 경우 정보 손실이 발생할 수 있음</strong>.</li> </ul> </li> </ul> <h3 id="2-awq-activation-aware-weight-quantization-2024--weight에서-activation으로-이상치-이동"><strong>2. AWQ (Activation-aware Weight Quantization, 2024) – Weight에서 Activation으로 이상치 이동</strong></h3> <p>AWQ는 <strong>Weight의 이상치를 줄이기 위해 Activation으로 분산시키는 방식</strong></p> <ul> <li><strong>기존 문제</strong> <ul> <li>SmoothQuant 방식처럼 이상치를 Weight 쪽으로 이동시키면, Weight의 크기가 커져서 <strong>Weight를 4-bit로 양자화할 때 정보 손실이 발생</strong>할 가능성이 높아짐.</li> <li>특히, Weight에 이상치가 많으면, <strong>스케일링을 적용해도 양자화 오류가 커지고 성능이 떨어지는 문제</strong>가 발생.</li> </ul> </li> <li><strong>해결 방법</strong> <ul> <li>대신 <strong>Weight에서 Activation으로 일부 이상치를 이동시켜서, Weight가 양자화될 때 정보 손실을 최소화</strong>함.</li> <li>즉, 중요한 Weight 값을 따로 보호하고, 불필요한 큰 값을 Activation 쪽으로 이동시켜서 Weight를 더 균등한 분포로 만들도록 설계.</li> </ul> </li> <li><strong>한계</strong> <ul> <li>Activation의 분포가 다시 넓어질 가능성이 있음 → <strong>Activation을 다시 4-bit로 양자화할 경우 문제가 발생할 수도 있음</strong>.</li> </ul> </li> </ul> <h3 id="3-svdquant-2024--outlier를-low-rank-component로-이동"><strong>3. SVDQuant (2024) – Outlier를 Low-Rank Component로 이동</strong></h3> <p>SVDQuant는 SmoothQuant와 AWQ의 문제점을 모두 해결하려고, <strong>이상치를 이동시키는 것뿐만 아니라 Low-Rank Component로 흡수</strong>하는 방식이야​Li 등 - 2024 - SVDQuan….</p> <ul> <li><strong>핵심 아이디어</strong> <ul> <li>SmoothQuant처럼 <strong>Activation의 이상치를 Weight로 이동</strong>하면서도,</li> <li>AWQ처럼 <strong>Weight에서 다시 Activation으로 이동하는 대신, Low-Rank Component로 분리하여 저장</strong>.</li> <li>즉, <strong>이상치를 양자화하지 않고, 16-bit Low-Rank Component로 유지</strong>하여 정보 손실을 최소화.</li> </ul> </li> <li><strong>장점</strong> <ul> <li>SmoothQuant나 AWQ처럼 <strong>한쪽으로 이상치를 몰아넣지 않고, Low-Rank Branch가 이상치를 흡수해서 손실을 막음</strong>.</li> <li><strong>Weight와 Activation 모두 균등한 분포를 가지게 되어, 양자화 오류가 줄어듦</strong>.</li> <li>실제 실험에서도 <strong>SmoothQuant, AWQ보다 4-bit 양자화에서 성능이 뛰어남</strong>.</li> </ul> </li> </ul> <h3 id="결론"><strong>결론</strong></h3> <ul> <li><strong>SmoothQuant</strong> → <strong>Activation의 이상치를 Weight로 이동</strong> (Weight의 정보 손실 가능성 있음)</li> <li><strong>AWQ</strong> → <strong>Weight의 이상치를 Activation으로 이동</strong> (Activation의 정보 손실 가능성 있음)</li> <li><strong>SVDQuant</strong> → <strong>Weight와 Activation에서 Low-Rank Component로 이동</strong> (이상치 자체를 제거하여 정보 손실을 최소화)</li> </ul> <p>즉, <strong>SmoothQuant과 AWQ는 둘 중 하나만 Outlier를 발생하지 않도록 하려고 했던 접근법</strong>, 반면 <strong>SVDQuant는 Outlier 자체를 Low-Rank로 빼버리는 방식이라 정보 손실이 가장 적음</strong>.</p> <h1 id="3-quantization-preliminary">3 QUANTIZATION PRELIMINARY</h1> <ul> <li><strong>양자화(Quantization)의 기본 개념</strong> <ul> <li>딥러닝에서 <strong>양자화는 연산 속도를 높이고 메모리 사용량을 줄이는 데 사용되는 방법</strong>.</li> <li>텐서 X를 양자화하는 과정:</li> </ul> </li> </ul> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%205.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    - 여기서 QX​는 **양자화된(low-bit) 값**.
    - sX는 **스케일링 팩터(Scaling Factor)**.
    - qmax는 **최대 양자화 값**(비트 수에 따라 달라짐).
    - **4비트 부동소수점 양자화(4-bit FP)에서는 qmax=6임.** - **양자화된 행렬 연산**
- 선형 계층(Linear Layer)에서 입력 X와 가중치 W가 있을 때, 연산을 양자화된 값으로 근사:
</code></pre></div></div> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%206.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 즉, 양자화된 텐서끼리 연산한 후, 스케일링 팩터 sX​sW​를 곱하여 다시 원래 값에 가깝게 복원함. - **GPU에서 같은 비트폭(bit width)을 사용해야 하는 이유**
- **최신 GPU에서는 입력(QX)과 가중치(QW)의 비트 수가 동일해야 연산 속도가 향상됨.**
- **만약 QX와 QW의 비트 수가 다르면, 더 높은 비트 값으로 변환(upcast)되면서 속도 이점이 사라짐.**
- 예:
    - **가중치(W)를 4비트로 양자화(W4)했지만, 활성화값(X)이 16비트(A16)라면?**
    → **연산 시 W4가 A16으로 업캐스트(Upcast)되어 실제 속도 향상이 없음.**
    → 따라서, **W4A4(가중치 4비트, 활성화값 4비트) 조합이 최적화된 방식.** - **W4A4 양자화에서의 문제점: Outlier(이상치)**
- **Diffusion 모델에서는 가중치(W)와 활성화값(X) 양쪽에서 Outlier(극단적인 값)가 많이 발생함.**
- **Outlier가 많으면 양자화 후 품질이 크게 저하됨.**
- 기존 해결 방법:
    1. **Quantization-Aware Training (QAT)**
        - **양자화를 고려하여 모델을 훈련하는 방식.**
        - **하지만, 100억 개 이상의 매개변수(예: FLUX.1 모델)를 조정하려면 계산 비용이 매우 큼.**
    2. **Rotation 기법** (Ashkboos et al., 2024; Liu et al., 2024c)
        - **가중치와 활성화값을 회전(rotation)하여 Outlier를 줄이는 방법.**
        - **하지만, Diffusion 모델의 "Adaptive Normalization Layer"에서는 적용이 어려움.**
        - 이유:
            - Adaptive Normalization은 **실행 시간(runtime) 중에 새로운 가중치를 생성**.
            - 따라서, **사전 계산된 회전 행렬을 적용할 수 없음.**
            - **실행 시간에 회전을 적용하면 연산량이 증가하여 속도가 느려짐.**
</code></pre></div></div> <blockquote class="block-warning"> <p>📢</p> <p><strong>이상치(Outlier)가 있으면 어떻게 성능이 저하될까?</strong></p> <h3 id="1-스케일링-팩터-문제"><strong>1. 스케일링 팩터 문제</strong></h3> <ul> <li>양자화는 데이터의 전체 범위(min-max)를 고려해서 값을 조정해야 하는데, 이상치가 있으면 <strong>스케일링 팩터가 비정상적으로 커짐</strong>.</li> <li> <p>대부분의 값은 작은 범위에 몰려 있는데, <strong>한두 개의 큰 값(이상치) 때문에 스케일이 커지면 작은 값들이 모두 0 또는 동일한 값으로 매핑되는 문제</strong>가 생겨.</p> <p><strong>예제:</strong></p> <ul> <li>원래 가중치 값: <code class="language-plaintext highlighter-rouge">[-0.1, -0.05, 0.0, 0.05, 0.1, 5.0]</code> (이상치: 5.0)</li> <li>이상치가 없을 때: <code class="language-plaintext highlighter-rouge">s_X = 0.1</code>, 범위를 <code class="language-plaintext highlighter-rouge">[-8, 7]</code>로 매핑 가능</li> <li>이상치(5.0)가 포함될 때: <code class="language-plaintext highlighter-rouge">s_X = 5.0</code>, 작은 값들은 모두 0이 되어 정보 손실 발생</li> </ul> </li> </ul> <h3 id="2-정보-손실-precision-loss"><strong>2. 정보 손실 (Precision Loss)</strong></h3> <ul> <li>이상치를 고려해 전체 값을 조정하면, 나머지 대부분의 값이 <strong>매우 작은 차이를 가지는데도 동일한 양자화된 값으로 표현</strong>될 가능성이 높아.</li> <li>즉, <strong>모델이 작은 변화(gradient 등)를 반영하지 못하고 표현력이 급격히 떨어짐</strong>.</li> </ul> <h3 id="3-활성화activation-이상치로-인해-연산량-증가"><strong>3. 활성화(Activation) 이상치로 인해 연산량 증가</strong></h3> <ul> <li>이상치가 있으면 양자화된 값을 다시 부동소수점으로 변환할 때 <strong>FP32(32-bit)로 변환하는 경우가 많아</strong>, 결국 연산 최적화가 깨짐.</li> <li>특히 Transformer 기반 모델에서는 Self-Attention 연산이 크기 때문에 <strong>활성화값(Activation)의 이상치는 메모리 사용량과 연산량 증가로 이어질 수 있음</strong>.</li> </ul> </blockquote> <h1 id="4-method">4 Method</h1> <h2 id="41-problem-formulation">4.1 PROBLEM FORMULATION</h2> <p>양자화의 오류를 다음과 같이 정의됨.</p> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%207.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>원래 행렬 곱셈 XW와 양자화된 값으로 연산한 Q(X)Q(W)의 차이를 측정하는 값</p> <p>좀 더 세분화</p> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%208.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%209.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="42-svdquant-absorbing-outliers-via-low-rank-branch">4.2 SVDQUANT: ABSORBING OUTLIERS VIA LOW-RANK BRANCH</h2> <h3 id="migrate-outliers-from-activation-to-weight">Migrate outliers from activation to weight</h3> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2010.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>After Smoothing 부분이 기존 기법인데, 단점이 있음</p> <ul> <li>✅ <strong>Activation(X)의 이상치를 없애는 것은 성공했지만</strong>,</li> <li>❌ <strong>대신 Weight(W)의 이상치가 증가하는 문제가 발생</strong>.</li> <li>결과적으로, <strong>전체적인 양자화 오류를 줄이려는 목적이 제대로 달성되지 않음</strong>.</li> </ul> <h3 id="absorb-magnified-weight-outliers-with-a-low-rank-branch">Absorb magnified weight outliers with a low-rank branch.</h3> <p><strong>Weight를 바로 4-bit로 양자화하지 않고, Low-Rank Component를 따로 분리해서 이상치를 흡수</strong>하는 전략</p> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2011.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2012.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="svdsingular-value-decomposition-특이값-분해">SVD(Singular Value Decomposition, 특이값 분해)</h3> <ul> <li>원래 행렬 크기가 m×n이면, 직접 곱하면 연산량이 <strong>O(mn)</strong>.</li> <li>하지만 SVD로 Rank r만 유지하면 <strong>연산량이 O(mr+rn)로 줄어듦</strong>.</li> </ul> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2013.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>포인트는 대각 원소(특이값, Singular Values)</p> <ul> <li><strong>큰 특이값들은 중요한 정보(패턴)를 나타냄</strong>.</li> <li><strong>작은 특이값들은 노이즈(이상치 포함)를 나타낼 가능성이 높음</strong>.</li> </ul> <h3 id="low-rank-분해">Low-Rank 분해</h3> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2014.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><strong>대각 원소 중에서 상위 r개의 특이값만 유지하여, 가장 중요한 정보만 포함하는 L1,L2를 생성.</strong></p> <p><strong>→ 따로 16-bit 연산</strong></p> <p><strong>남은 부분(작은 특이값) → R으로 분리</strong></p> <p><strong>→ 4-bit 연산</strong></p> <p>→ 작은 특이값만 남았으므로 R을 <strong>4-bit로 양자화하더라도 정보 손실이 크게 줄어듦</strong></p> <h2 id="43-nunchaku-fusing-low-rank-and-low-bit-branch-kernels">4.3 NUNCHAKU: Fusing Low-Rank and Low-Bit Branch Kernels</h2> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2015.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="low-rank-branch에서-발생하는-성능-저하-문제"><strong>Low-Rank Branch에서 발생하는 성능 저하 문제</strong></h3> <ul> <li><strong>QKV Projection과 같은 연산에서는 Low-Rank Branch가 L2 캐시를 초과하면서 DRAM에서 데이터를 불러와야 함</strong>.</li> <li>이는 <strong>메모리 접근 비용이 증가하여 연산 속도가 떨어지는 원인</strong>.</li> <li><strong>Figure 6(a)에서 보듯이, Low-Rank Branch는 전체 4-bit 연산 지연의 50%를 차지</strong>.</li> </ul> <h3 id="nunchaku-해결-방법"><strong>NUNCHAKU: 해결 방법</strong></h3> <ul> <li>논문에서는 <strong>Low-Rank Branch와 Low-Bit Branch의 연산을 하나로 합쳐(fusing) 메모리 접근을 줄이는 방법을 제안</strong>.</li> <li><strong>Figure 6(b)에서 보듯이, 두 개의 Kernel을 합쳐서 데이터를 공유함</strong>: <ol> <li><strong>Down Projection 연산을 Quantization Kernel과 합침</strong>.</li> <li><strong>Up Projection 연산을 4-bit 연산 Kernel과 합침</strong>.</li> </ol> </li> <li>이를 통해 <strong>Low-Rank Branch가 Low-Bit Branch와 활성화값을 공유할 수 있어, 추가적인 메모리 접근을 제거</strong>.</li> <li>결과적으로, <strong>Kernel 호출 횟수가 절반으로 줄어들어 속도 개선 효과가 있음</strong>.</li> </ul> <h1 id="5-experiments">5 Experiments</h1> <h3 id="benchmark-models">Benchmark models</h3> <table> <thead> <tr> <th>Model</th> <th>Architecture</th> <th>Parameters</th> <th>Special Features</th> </tr> </thead> <tbody> <tr> <td>FLUX.1-dev</td> <td>DiT</td> <td>12B</td> <td>50-step guidance-distilled</td> </tr> <tr> <td>FLUX.1-schnell</td> <td>DiT</td> <td>12B</td> <td>4-step timestep-distilled</td> </tr> <tr> <td>PixArt-Σ</td> <td>DiT</td> <td>600M</td> <td>20-step default</td> </tr> <tr> <td>SANA</td> <td>DiT</td> <td>1.6B</td> <td>32× compression autoencoder, Linear Attention</td> </tr> <tr> <td>SDXL</td> <td>UNet</td> <td>2.6B</td> <td>30-step</td> </tr> </tbody> </table> <h3 id="baselines-quantization">Baselines Quantization</h3> <table> <thead> <tr> <th>Method</th> <th>Description</th> <th>Usage in Benchmarking</th> </tr> </thead> <tbody> <tr> <td>NF4<br/>(4-bit NormalFloat)</td> <td>Optimized 4-bit weight-only quantization assuming normal distribution</td> <td>Used as a weight-only quantization baseline for FLUX.1</td> </tr> <tr> <td>ViDiT-Q</td> <td>Per-token quantization + smoothing to reduce outliers</td> <td>Achieves lossless 8-bit quantization on PixArt-Σ</td> </tr> <tr> <td>MixDQ</td> <td>Detects outliers in text embeddings and protects them with 16-bit pre-computation</td> <td>Enables W4A8 quantization with minimal performance drop on SDXL-Turbo</td> </tr> <tr> <td>TensorRT</td> <td>Industry-standard PTQ toolkit for 8-bit quantization</td> <td>Uses smoothing + percentile calibration over specific timesteps</td> </tr> </tbody> </table> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2016.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2017.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2018.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2019.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2020.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h1 id="limitation">Limitation</h1> <p>엄청난 기술이고 기술면에서는 한계가 없다고 생각함.</p> <p>하지만, 굳이 한계점을 뽑자면, Song Han이 NVIDIA에서도 연구를 진행하기 때문에 NVIDIA chip만을 위해서 코드를 짰고, 이에 최적화되어있다.</p> <p>심지어 CUDA 12.2 이상에서만 작동 가능해서 내 학교 서버로 돌려보려고 했는데, GPU Driver version이 낮아서 안돌아가더라.</p> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2021.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>물론 NVIDIA chip에서 극한의 최적화를 위해서 였지만, 다른 GPU 장비에서는 이를 사용할 수 없다.</p> <p>같은 방식을 다른 GPU 장비와 Mobile edge device들에 적용한다면 좋을 것이다.</p> <h1 id="질문과-답변">질문과 답변</h1> <h2 id="메모리랑-추론시간만-줄인게-아닌가-정확도를-왜-언급">메모리랑 추론시간만 줄인게 아닌가? 정확도를 왜 언급?</h2> <h3 id="memory-latency">Memory, Latency?</h3> <p>아래 그림과 같이 SVD양자화로 인해 메모리와 latency 이점을 얻은게 포인트 아닌가?</p> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2022.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>비교가 기존 16bit / W4A16 / W4A4(SVD) 였기 때문에 큰 차이를 보여준 것 같다.</p> <p>Inference time과 Memory 줄인게 포인트인줄 알았는데 완전 잘못 생각한것 같기도 합니다.</p> <p>물론 Outlier때문에 32bit로 처리했던 부분들이 없어지고 16bit로 low rank로 따로 빼니까 향상은 됐을 것이지만, 제 생각에는 SVD 없는 W4A4랑 비교했다면, Memory와 추론시간이 3배 이상 차이나지는 않을 것입니다.</p> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2023.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="정확도">정확도?</h3> <p>기존 양자화에서 정확도를 유지하는 부분이 아래 그림처럼 많이 떨어졌었다.</p> <p>(두번째가 기존 양자화 기법, 심지어 W4A4가 아닌 W4A16인데도 더 떨어지는 모습을 보임)</p> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2024.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="보존-할-수-있었던-이유--low-rank-branch">보존 할 수 있었던 이유 → Low-Rank Branch</h3> <ul> <li>기존 4-bit 양자화 방식에서는 <strong>Weight 전체를 4-bit로 변환</strong>하므로 정보 손실이 큼.</li> <li>SVDQuant는 Weight를 Low-Rank Component (L1L2) 와 잔여 (R)로 분해한다.</li> </ul> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2025.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li>L1L2는 16-bit precision으로 유지 → 중요한 정보는 고정밀도로 남겨둠.</li> <li><strong>잔여 R만 4-bit로 양자화하여 정보 손실을 최소화함</strong></li> <li>한 번만 Low-Rank 분해하는 것이 아니라, <strong>반복적으로 R을 최적화</strong>하여 양자화 오류를 최소화</li> </ul> <h3 id="quantization-error">quantization error</h3> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2026.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>이 식에서 L1L2+R로 분해함으로서 Quantization을 진행하면서 발생하는 Error를 최대한 줄인거임.</p> <p>Quantization 자체가 Outlier로 인해서 정확도를 떨어뜨릴 수 밖에 없는데, 이를 최대한 보존했다는 점이 엄청난 연구인 것임!!!!</p> <h2 id="svd를-llm에-써도-되는가-왜-diffusion으로-논문을">SVD를 LLM에 써도 되는가? 왜 Diffusion으로 논문을?</h2> <p>기존 제 생각 : 적용 할 수는 있을 것 같으나, LLM은 병목현상이 무거운 모델을 불러오는 과정에서 나타나므로 뒤에 연산을 줄여도 Diffusion만큼 큰 효과는 나타날 지 모르겠습니다. (Diffusion은 연산이 병목임)</p> <p>물론 기존 제 생각도 찾아보니 맞는 것 같으나, 실제로 활용한다면, 바로 위 질문에서 다뤘던 정확도 향상에도 도움이 되기 때문에, 오히려 정확도 부분에서 도움이 될 것 같습니다.</p> <h3 id="기존-양자화">기존 양자화</h3> <ul> <li><strong>GPTQ</strong> → Post-training quantization 방식, Weight만 4-bit 변환.</li> <li><strong>AWQ</strong> → Weight 중요도를 분석해 선택적으로 4-bit 변환.</li> <li><strong>SmoothQuant</strong> → Activation 이상치를 Weight로 이동시켜 양자화 오류를 줄이는 방식.</li> </ul> <h3 id="svdquant-사용한다면">SVDQuant 사용한다면?</h3> <p>Weight를 Low-Rank(16-bit) + Residual(4-bit)로 나누어 중요한 정보는 유지하면서 압축하므로</p> <p>Diffusion처럼 정확도 향상에 도움이 될듯 !!!</p> <h2 id="for-an-explanation-from-the-author-song-han">For an explanation from the author, Song Han</h2> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2027.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p><a href="https://www.youtube.com/watch?v=nYujDH9r69s&amp;t=1s">Youtube [Introduction to SVDQuant for 4-bit Diffusion Models]</a></p> <h2 id="demo">Demo</h2> <p><a href="https://hanlab.mit.edu/projects/svdquant">[https://hanlab.mit.edu/projects/svdquant](https://hanlab.mit.edu/projects/svdquant)</a></p> <figure> <picture> <img src="/files/2025-03-06-svdquant/image%2028.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure>]]></content><author><name></name></author><category term="Paper"/><category term="AI"/><summary type="html"><![CDATA[Authors: Muyang Li, Yujun Lin, Zhekai Zhang*, Tianle Cai, Xiuyu Li, Junxian Guo, Enze Xie, Chenlin Meng, Jun-Yan Zhu, Song Han MIT, NVIDIA, CMU, Princeton, UC Berkeley, SJTU, Pika Labs Venue &amp; Year: 25, ICLR, Spotlight 날짜: 2025년 3월 6일]]></summary></entry><entry><title type="html">Ablation Study 란?</title><link href="https://hoonably.github.io/blog/Ablation-Study/" rel="alternate" type="text/html" title="Ablation Study 란?"/><published>2025-03-05T08:20:00+00:00</published><updated>2025-03-05T08:20:00+00:00</updated><id>https://hoonably.github.io/blog/Ablation-Study</id><content type="html" xml:base="https://hoonably.github.io/blog/Ablation-Study/"><![CDATA[<p><a href="https://hanlab.mit.edu/projects/svdquant">SVDQuant Project</a></p> <p>논문을 읽다가 도대체 Ablation Study가 뭐지? 했다.</p> <p>한국어로 직역하면 절제 연구인데 해석해도 이게 뭔지 싶어서 궁금해서 찾아봤다.</p> <blockquote> <p>모델에서 특정 요소를 제거하거나 변경하면서 해당 요소가 성능에 미치는 영향을 분석하는 실험</p> </blockquote> <hr/> <h3 id="-ablation-study의-목적">💡 Ablation Study의 목적</h3> <ol> <li>각 구성 요소의 중요도 평가 <ul> <li>모델에서 특정 요소(예: 특정 레이어, 손실 함수, 데이터 처리 기법 등)를 제거하거나 수정했을 때 성능이 얼마나 떨어지는지 본다.</li> <li>예를 들어 “SVDQuant에서 SVD를 안 쓰면 성능이 어떻게 되지?” 같은 실험.</li> </ul> </li> <li>최적의 모델 구성 찾기 <ul> <li>여러 요소를 실험적으로 비교하면서 불필요한 부분을 제거해 <strong>더 가볍고 빠른 모델</strong>을 만들 수도 있음.</li> </ul> </li> <li>이론적 정당성 검증 <ul> <li>“우리가 제안한 방법이 정말 효과가 있는지?”를 증명하는 과정.</li> </ul> </li> </ol> <hr/> <h3 id="-예제-svdquant-논문에서-ablation-study">💡 예제: SVDQuant 논문에서 Ablation Study</h3> <figure> <picture> <img src="https://github.com/user-attachments/assets/f36e5dd1-951f-44e7-a2a0-37ab7ec0aa11" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>SVDQuant 논문에서는 <strong>Figure 10</strong>에서 다양한 실험을 함:</p> <ul> <li><strong>SVD만 적용</strong> → 성능이 낮아짐 ❌</li> <li><strong>기본적인 4-bit 양자화</strong> → 품질이 많이 떨어짐 ❌</li> <li><strong>Smoothed Quantization 추가</strong> → 조금 나아지지만 여전히 부족함 ❌</li> <li><strong>LoRC 방식 적용</strong> → 효과가 적음 ❌</li> <li><strong>SVDQuant 방식 적용</strong> → 가장 좋은 결과 ✅</li> </ul> <p>즉, <strong>각 요소를 하나씩 제거하면서 실험</strong>을 진행해서 “SVDQuant가 왜 효과적인가?”를 증명함.</p> <hr/> <h3 id="-쉽게-비유하면">💡 쉽게 비유하면?</h3> <p>Ablation Study는 마치 <strong>요리에서 특정 재료를 빼보면서 맛이 어떻게 변하는지 실험하는 과정</strong>과 비슷함</p> <ul> <li>카레를 만들면서 <strong>“양파를 빼면?”</strong>, <strong>“후추를 빼면?”</strong>, <strong>“소금을 줄이면?”</strong> 하는 식으로 실험</li> <li>최종적으로 “이 재료가 핵심이구나!”를 찾아내는 과정</li> </ul> <p>그래서 논문에서 <strong>Ablation Study</strong>라고 하면 “<strong>이 기능이 없었으면 어땠을까?</strong>“를 실험한 부분이라고 생각하면 됨.</p>]]></content><author><name></name></author><category term="Study"/><summary type="html"><![CDATA[SVDQuant Project]]></summary></entry><entry><title type="html">Ablation Study 란?</title><link href="https://hoonably.github.io/blog/ablation-study/" rel="alternate" type="text/html" title="Ablation Study 란?"/><published>2025-03-05T08:20:00+00:00</published><updated>2025-03-05T08:20:00+00:00</updated><id>https://hoonably.github.io/blog/ablation-study</id><content type="html" xml:base="https://hoonably.github.io/blog/ablation-study/"><![CDATA[<p><a href="https://hanlab.mit.edu/projects/svdquant">SVDQuant Project</a></p> <p>논문을 읽다가 도대체 Ablation Study가 뭐지? 했다.</p> <p>한국어로 직역하면 절제 연구인데 해석해도 이게 뭔지 싶어서 궁금해서 찾아봤다.</p> <blockquote> <p>모델에서 특정 요소를 제거하거나 변경하면서 해당 요소가 성능에 미치는 영향을 분석하는 실험</p> </blockquote> <hr/> <h3 id="-ablation-study의-목적">💡 Ablation Study의 목적</h3> <ol> <li>각 구성 요소의 중요도 평가 <ul> <li>모델에서 특정 요소(예: 특정 레이어, 손실 함수, 데이터 처리 기법 등)를 제거하거나 수정했을 때 성능이 얼마나 떨어지는지 본다.</li> <li>예를 들어 “SVDQuant에서 SVD를 안 쓰면 성능이 어떻게 되지?” 같은 실험.</li> </ul> </li> <li>최적의 모델 구성 찾기 <ul> <li>여러 요소를 실험적으로 비교하면서 불필요한 부분을 제거해 <strong>더 가볍고 빠른 모델</strong>을 만들 수도 있음.</li> </ul> </li> <li>이론적 정당성 검증 <ul> <li>“우리가 제안한 방법이 정말 효과가 있는지?”를 증명하는 과정.</li> </ul> </li> </ol> <hr/> <h3 id="-예제-svdquant-논문에서-ablation-study">💡 예제: SVDQuant 논문에서 Ablation Study</h3> <figure> <picture> <img src="https://github.com/user-attachments/assets/f36e5dd1-951f-44e7-a2a0-37ab7ec0aa11" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>SVDQuant 논문에서는 <strong>Figure 10</strong>에서 다양한 실험을 함:</p> <ul> <li><strong>SVD만 적용</strong> → 성능이 낮아짐 ❌</li> <li><strong>기본적인 4-bit 양자화</strong> → 품질이 많이 떨어짐 ❌</li> <li><strong>Smoothed Quantization 추가</strong> → 조금 나아지지만 여전히 부족함 ❌</li> <li><strong>LoRC 방식 적용</strong> → 효과가 적음 ❌</li> <li><strong>SVDQuant 방식 적용</strong> → 가장 좋은 결과 ✅</li> </ul> <p>즉, <strong>각 요소를 하나씩 제거하면서 실험</strong>을 진행해서 “SVDQuant가 왜 효과적인가?”를 증명함.</p> <hr/> <h3 id="-쉽게-비유하면">💡 쉽게 비유하면?</h3> <p>Ablation Study는 마치 <strong>요리에서 특정 재료를 빼보면서 맛이 어떻게 변하는지 실험하는 과정</strong>과 비슷함</p> <ul> <li>카레를 만들면서 <strong>“양파를 빼면?”</strong>, <strong>“후추를 빼면?”</strong>, <strong>“소금을 줄이면?”</strong> 하는 식으로 실험</li> <li>최종적으로 “이 재료가 핵심이구나!”를 찾아내는 과정</li> </ul> <p>그래서 논문에서 <strong>Ablation Study</strong>라고 하면 “<strong>이 기능이 없었으면 어땠을까?</strong>“를 실험한 부분이라고 생각하면 됨.</p>]]></content><author><name></name></author><category term="Study"/><summary type="html"><![CDATA[SVDQuant Project]]></summary></entry><entry><title type="html">Python env (Conda, Homebrew)</title><link href="https://hoonably.github.io/blog/python-env/" rel="alternate" type="text/html" title="Python env (Conda, Homebrew)"/><published>2025-02-17T07:26:20+00:00</published><updated>2025-02-17T07:26:20+00:00</updated><id>https://hoonably.github.io/blog/python-env</id><content type="html" xml:base="https://hoonably.github.io/blog/python-env/"><![CDATA[<h1 id="python--python3-alias">Python → Python3 alias</h1> <p>alias는 말그대로 별칭을 설정해주는 명령어</p> <p>python이라는 명령어를 실행하면 python3로 동작하도록 해라!는 의미</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">alias </span><span class="nv">python</span><span class="o">=</span>python3
</code></pre></div></div> <h1 id="macos-기본">macOS 기본</h1> <ul> <li>macOS 기본포함</li> <li>/usr/bin/python3 (비추천, 유지보수 어려움)</li> <li>아래 패키지들은 macOS 기본 패키지라 지울 필요 없음</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/usr/bin/python3 <span class="nt">-m</span> pip list
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 맥 기본 환경</span>
Package    Version
<span class="nt">----------</span> <span class="nt">-------</span>
altgraph   0.17.2
future     0.18.2
macholib   1.15.2
pip        25.0.1
setuptools 58.0.4
six        1.15.0
wheel      0.37.0
</code></pre></div></div> <h1 id="homebrew">⭐ Homebrew</h1> <ul> <li>brew install python으로 쉽게 설치 가능.</li> <li>최신 Python 버전을 사용할 수 있음.</li> <li>/opt/homebrew/bin/python3에 설치됨</li> <li><code class="language-plaintext highlighter-rouge">pip3</code>으로 패키지를 관리 가능하며, 시스템 기본 Python과 분리됨.</li> <li> <p>설치</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  /bin/bash <span class="nt">-c</span> <span class="s2">"</span><span class="si">$(</span>curl <span class="nt">-fsSL</span> <span class="o">[</span>https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh]<span class="o">(</span>https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh<span class="o">)</span><span class="si">)</span><span class="s2">"</span>
</code></pre></div> </div> </li> <li> <p>Homebrew를 기본으로 사용</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">echo</span> <span class="s1">'export PATH="/opt/homebrew/bin:$PATH"'</span> <span class="o">&gt;&gt;</span> ~/.zshrc
  <span class="nb">source</span> ~/.zshrc
</code></pre></div> </div> </li> <li> <p>설치 확인</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  which brew
  brew <span class="nt">-v</span>
</code></pre></div> </div> </li> </ul> <h1 id="anaconda">⭐ Anaconda</h1> <ul> <li>데이터 과학, 머신러닝(ML), 과학 컴퓨팅 환경에 최적화됨.</li> <li>패키지 관리가 쉽고, conda 명령어로 가상환경을 만들고 관리할 수 있음.</li> <li> <p>Jupyter Notebook, SciPy, TensorFlow 등 주요 데이터 과학 라이브러리가 기본적으로 포함됨.</p> <p>→ AI 관련 일을 할 때 가상환경을 만들어서 활용하자.</p> </li> <li>homebrew를 통한 설치</li> </ul> <p>→ 경로가 homebrew/anaconda 로 설치됨</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew <span class="nb">install</span> <span class="nt">--cask</span> anaconda 
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 설치 중 다음과 같은 내용이 콘다가 설치된 위치임</span>
<span class="c"># 이 위치를 ~/.zshrc 파일에 추가</span>
<span class="nv">PREFIX</span><span class="o">=</span>/opt/homebrew/anaconda3
</code></pre></div></div> <ul> <li> <p><code class="language-plaintext highlighter-rouge">~/.zshrc</code> 파일에 homebrew내용 주석처리하고 다음 추가</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c"># export PATH="/opt/homebrew/bin:$PATH"</span>
  <span class="nb">export </span><span class="nv">PATH</span><span class="o">=</span><span class="s2">"/opt/homebrew/anaconda3/bin:</span><span class="nv">$PATH</span><span class="s2">"</span>
</code></pre></div> </div> </li> <li> <p>설치 확인</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">source</span> ~/.zshrc
  which conda
  conda <span class="nt">-V</span>
</code></pre></div> </div> </li> </ul> <h2 id="conda-가상환경">conda 가상환경</h2> <ul> <li>가상환경 생성</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda create <span class="nt">--name</span> &lt;환경명&gt; <span class="nv">python</span><span class="o">=</span>&lt;파이썬 버전&gt;
conda create <span class="nt">--name</span> py39 <span class="nv">python</span><span class="o">=</span>3.9
</code></pre></div></div> <ul> <li>가상환경 활성화</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda activate &lt;환경명&gt;
conda activate py39
</code></pre></div></div> <ul> <li>가상환경 비활성화</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda deactivate
</code></pre></div></div> <ul> <li>가상환경 내 패키지 설치</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda <span class="nb">install</span> &lt;패키지명&gt;
</code></pre></div></div> <ul> <li>가상환경 목록 확인</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda <span class="nb">env </span>list
</code></pre></div></div> <ul> <li>가상환경 삭제</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda remove <span class="nt">--name</span> &lt;환경명&gt; <span class="nt">--all</span>
<span class="c"># conda remove --name py39 --all</span>
</code></pre></div></div> <ul> <li>이름변경 → 안됨 → 복제 후 삭제</li> </ul> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda create <span class="nt">--name</span> &lt;새로운 환경&gt; <span class="nt">--clone</span> &lt;삭제할 환경&gt;
conda remove <span class="nt">--name</span> &lt;삭제할 환경&gt; <span class="nt">--all</span>
</code></pre></div></div> <h3 id="conda-초기화">conda 초기화</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>conda init zsh
<span class="nb">source</span> ~/.zshrc
</code></pre></div></div> <h3 id="자동-콘다-실행-없애기--맥-기본-파이썬이-기본">자동 콘다 실행 없애기 → 맥 기본 파이썬이 기본</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># base 자동 활성화 끄기</span>
conda config <span class="nt">--set</span> auto_activate_base <span class="nb">false
source</span> ~/.zshrc

<span class="c"># 반대는 true로 바꾸면 됨</span>
</code></pre></div></div> <h3 id="base만-표시-없애고-나머지는-py36처럼-뜨도록">(base)만 표시 없애고 나머지는 (py36)처럼 뜨도록</h3> <p>다음 내용을 .zshrc에 저장</p> <p><code class="language-plaintext highlighter-rouge">conda config --set auto_activate_base false</code> 여야함</p> <p>기본은 원래 맥 기본 파이썬인데, 2)에서 자동으로 base 활성화</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># &gt;&gt;&gt; base 환경에서만 (base) 숨기기 &gt;&gt;&gt;</span>
<span class="c"># 1) 초기 PS1 저장 (중복 방지용 체크)</span>
<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$ORIGINAL_PS1</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">export </span><span class="nv">ORIGINAL_PS1</span><span class="o">=</span><span class="s2">"</span><span class="nv">$PS1</span><span class="s2">"</span>
<span class="k">fi</span>
<span class="c"># 2) base 자동 활성화</span>
conda activate base
<span class="c"># 3) base일 때만 (base) 표시를 숨기는 함수</span>
<span class="k">function </span>_conda_prompt_override<span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">[[</span> <span class="nv">$CONDA_DEFAULT_ENV</span> <span class="o">==</span> <span class="s2">"base"</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
        <span class="c"># base일 때 프롬프트를 원래 PS1으로 돌려서 (base) 숨기기</span>
        <span class="nv">PS1</span><span class="o">=</span><span class="s2">"</span><span class="nv">$ORIGINAL_PS1</span><span class="s2">"</span>
    <span class="k">fi</span>
    <span class="c"># base가 아닐 땐, (env_name)이 그대로 표시됨</span>
<span class="o">}</span>
<span class="c"># 4) Zsh의 precmd_functions에 등록</span>
precmd_functions+<span class="o">=(</span>_conda_prompt_override<span class="o">)</span>
<span class="c"># &lt;&lt;&lt; base 환경에서만 (base) 숨기기 &lt;&lt;&lt;</span>
</code></pre></div></div> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">source</span> ~/.zshrc
</code></pre></div></div> <h1 id="pyenv">pyenv</h1> <p>여러 Python 버전을 관리해야 한다면 유용</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pyenv <span class="o">(</span>pyenv <span class="nb">install</span> &lt;version&gt;<span class="o">)</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="Tip"/><summary type="html"><![CDATA[Python → Python3 alias]]></summary></entry><entry><title type="html">PixArt-Σ: Weak-to-Strong Training of Diffusion Transformer for 4K Text-to-Image Generation</title><link href="https://hoonably.github.io/blog/pixart-sigma/" rel="alternate" type="text/html" title="PixArt-Σ: Weak-to-Strong Training of Diffusion Transformer for 4K Text-to-Image Generation"/><published>2025-02-09T07:09:52+00:00</published><updated>2025-02-09T07:09:52+00:00</updated><id>https://hoonably.github.io/blog/pixart-sigma</id><content type="html" xml:base="https://hoonably.github.io/blog/pixart-sigma/"><![CDATA[<p>Authors: Junsong Chen, Chongjian Ge, Enze Xie, Yue Wu, Lewei Yao, Xiaozhe Ren, Zhongdao Wang, Ping Luo, Huchuan Lu, Zhenguo Li Venue &amp; Year: 24, ArXiv 날짜: 2025년 2월 9일</p> <table> <thead> <tr> <th>ArXiv</th> <th>https://arxiv.org/abs/2403.04692</th> </tr> </thead> <tbody> <tr> <td>Project Page</td> <td>https://pixart-alpha.github.io/PixArt-sigma-project/</td> </tr> <tr> <td>Github Code</td> <td>https://github.com/PixArt-alpha/PixArt-sigma</td> </tr> </tbody> </table> <p><a href="https://www.notion.so/PixArt-Fast-Training-of-Diffusion-Transformer-for-Photorealistic-Text-to-Image-Synthesis-198451cf7b798018891cfb85e1cd3523?pvs=21"><strong>PixArt-α: Fast Training of Diffusion Transformer for Photorealistic Text-to-Image Synthesis</strong></a></p> <blockquote class="block-warning"> <p>💡</p> <p><strong>Key Differentiator</strong></p> <ul> <li>기존 연구였던 PixArt-α에서 최적화를 통해 4K 초고해상도까지 가능하도록 연구</li> <li>4K를 transformer를 활용해 directly로 한번에 생성</li> </ul> </blockquote> <h1 id="2-related-work">2. Related Work</h1> <h3 id="1️⃣-pixart-α-iclr-2024-spotlight"><strong>1️⃣ PixArt-α (ICLR 2024 Spotlight)</strong></h3> <ul> <li><strong>최초의 Transformer 기반 Diffusion Model (DiT)로 1024×1024 해상도까지 생성 가능</strong></li> </ul> <h3 id="2️⃣-stable-diffusion-xl-sdxl-2023"><strong>2️⃣ Stable Diffusion XL (SDXL, 2023)</strong></h3> <ul> <li><strong>Latent Diffusion Model (LDM) 구조를 활용하여 1024×1024 이상의 고해상도 이미지 생성 가능</strong></li> </ul> <h3 id="3️⃣-gigagan-adobe-2023"><strong>3️⃣ GigaGAN (Adobe, 2023)</strong></h3> <ul> <li><strong>GAN 기반 초고해상도 이미지 생성 모델 (1024px 이상 지원)</strong></li> </ul> <h3 id="4️⃣-llava-visual-instruction-tuning-2023"><strong>4️⃣ LLaVA (Visual Instruction Tuning, 2023)</strong></h3> <ul> <li><strong>이미지-텍스트 정렬을 학습하여 이미지에 대한 설명(캡션)을 자동으로 생성하는 모델</strong></li> </ul> <h3 id="5️⃣-dalle-3-openai-2023"><strong>5️⃣ DALL·E 3 (OpenAI, 2023)</strong></h3> <ul> <li><strong>GPT-4 기반 텍스트 이해력을 활용하여 프롬프트를 더 정밀하게 반영</strong></li> </ul> <h1 id="3-framework">3. Framework</h1> <h2 id="31-data-analysis">3.1 Data Analysis</h2> <table> <thead> <tr> <th> </th> <th><strong>Data</strong></th> <th> </th> </tr> </thead> <tbody> <tr> <td>Internal-α</td> <td>14M</td> <td> </td> </tr> <tr> <td><strong>Internal-Σ</strong></td> <td><strong>33M</strong></td> <td>&gt;=1K (33M)<br/>real photo 4K (8M)</td> </tr> <tr> <td>SD v1.5<br/>(open-source)</td> <td>2B</td> <td> </td> </tr> </tbody> </table> <p>a 때보다 데이터가 많이 늘었고, 4K real photo도 추가함.</p> <p>하지만 SD v1.5가 2B 데이터인걸 감안하면 아주 제한적인 데이터.</p> <p>하지만 효과적으로 training함.</p> <p>이미지의 예술적 품질을 평가하는 Aesthetic Scoring Model(AES)을 사용하여 <strong>2M(200만 장)의 고품질 이미지 선별</strong>.</p> <p>→ 해상도가 높아질수록 모델의 충실도(프레셰 초점 거리(FID) [18])와 의미적 정렬(CLIP 점수)이 향상</p> <h3 id="better-text-image-alignment">Better Text-Image Alignment</h3> <p>➡ <strong>텍스트 프롬프트(설명)와 생성된 이미지가 얼마나 일치하는지</strong></p> <p><strong>즉, 사용자가 입력한 텍스트(prompt)와 모델이 생성한 이미지가 얼마나 정확하게 대응하는지를 평가하는 개념</strong></p> <hr/> <p>PixArt-α 는 LLaVa를 사용하였고, PixArt-Σ는 Share-Captioner 사용</p> <table> <thead> <tr> <th>항목</th> <th>LLaVA</th> <th>Share-Captioner</th> </tr> </thead> <tbody> <tr> <td><strong>기반 모델</strong></td> <td>CLIP + LLaMA</td> <td>GPT-4V (GPT-4 with Vision)</td> </tr> <tr> <td><strong>텍스트 생성</strong></td> <td>비교적 단순</td> <td>더 길고 세밀한 설명</td> </tr> <tr> <td><strong>정확도</strong></td> <td>가끔 환각 문제 발생</td> <td>더 높은 정확도</td> </tr> <tr> <td><strong>이미지 디테일 반영</strong></td> <td>제한적 (단순 설명)</td> <td>더 정밀한 객체 및 관계 설명</td> </tr> <tr> <td><strong>캡션 품질</strong></td> <td>일반적인 설명 수준</td> <td>고품질, 구체적인 묘사 가능</td> </tr> </tbody> </table> <p>다음과 같은 환각 (Hallucinations)가 발생했었음</p> <figure> <picture> <img src="/files/2025-02-09-pixart-sigma/image.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <table> <thead> <tr> <th><strong>항목</strong></th> <th><strong>PixArt-α</strong></th> <th><strong>PixArt-Σ</strong></th> </tr> </thead> <tbody> <tr> <td><strong>텍스트 해석 길이</strong></td> <td>120 토큰</td> <td><strong>300 토큰 (2.5배 증가)</strong></td> </tr> <tr> <td><strong>캡션 생성 모델</strong></td> <td>LLaVA (단순함)</td> <td><strong>Share-Captioner (정확한 설명)</strong></td> </tr> <tr> <td><strong>CLIP Score</strong></td> <td>0.2787</td> <td><strong>0.2797 (향상됨)</strong></td> </tr> <tr> <td><strong>환각 문제 해결</strong></td> <td>일부 존재</td> <td><strong>환각 감소 (더 정밀한 캡션 사용)</strong></td> </tr> </tbody> </table> <p>➡ <strong>PixArt-Σ는 더 긴 문장을 해석하고, 더 정교한 캡션을 사용하여 텍스트-이미지 정렬 성능을 높였음</strong>.</p> <p>➡ <strong>Share-Captioner를 사용하여 텍스트와 이미지 간 정보 일치도를 개선</strong>함.</p> <h3 id="평가-데이터셋-구성-high-quality-evaluation-dataset">평가 데이터셋 구성 (High-Quality Evaluation Dataset)</h3> <ul> <li>기존 모델들이 사용하는 <strong>MSCOCO 데이터셋은 예술적 품질과 텍스트-이미지 정렬을 평가하기에 충분하지 않음</strong>.</li> <li>따라서 PixArt-Σ는 <strong>새로운 평가 데이터셋(30,000개 샘플) 구축</strong>.</li> <li>평가 항목: <ol> <li><strong>Fréchet Inception Distance (FID)</strong> → 이미지 품질 평가</li> <li><strong>CLIP Score</strong> → 텍스트-이미지 정렬 성능 평가</li> </ol> </li> </ul> <figure> <picture> <img src="/files/2025-02-09-pixart-sigma/image%201.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="32-efficient-dit-design">3.2 Efficient DiT Design</h2> <h3 id="key-value-kv-token-compression-기법"><strong>Key-Value (KV) Token Compression 기법</strong></h3> <p><strong>🔹 기존 Attention 연산 문제</strong></p> <ul> <li>Self-Attention은 <strong>Query(Q), Key(K), Value(V)의 곱을 계산</strong>하는 방식이므로,토큰 개수가 많아질수록 <strong>연산량이 O(N²)으로 증가</strong>함.</li> <li><strong>해결 방법</strong>: Key와 Value 토큰을 압축하여 연산량을 줄임.</li> </ul> <p><strong>🔹 PixArt-Σ의 KV Token Compression 방식</strong></p> <figure> <picture> <img src="/files/2025-02-09-pixart-sigma/image%202.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <ul> <li><strong>PixArt-Σ (토큰 압축 적용)</strong>: <ul> <li>Key(K)와 Value(V)를 <strong>Stride 2의 Group Convolution</strong>을 사용해 압축</li> <li>이를 통해 토큰 개수를 <strong>N → N/R^2 으로 줄임</strong></li> <li>정확도가 크게 떨어지지 않는 선에서 R을 조정 (1~4)하기</li> <li>최종적으로 <strong>연산량을 기존 대비 약 34% 절감</strong></li> </ul> </li> </ul> <p><strong>핵심 효과</strong></p> <ul> <li><strong>4K 해상도 이미지 생성 속도 향상</strong> (연산량 감소)</li> <li><strong>메모리 사용량 감소 → 더 작은 GPU에서도 실행 가능</strong></li> <li><strong>기존 PixArt-α 모델에서 자연스럽게 업그레이드 가능</strong> (기존 모델의 가중치를 활용)</li> </ul> <figure> <picture> <img src="/files/2025-02-09-pixart-sigma/image%203.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <figure> <picture> <img src="/files/2025-02-09-pixart-sigma/image%204.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="33-weak-to-strong-training-strategy">3.3 Weak-to-Strong Training Strategy</h2> <p>PixArt-Σ의 Weak-to-Strong Training은 <strong>기존 모델의 가중치를 활용하여 빠르게 적응하도록 설계됨</strong>.</p> <p>이 과정에서 <strong>3단계의 학습 전략</strong>이 적용됨.</p> <h3 id="1-vae-적응-vae-adaptation"><strong>(1) VAE 적응 (VAE Adaptation)</strong></h3> <ul> <li>PixArt-α에서 사용하던 기존 VAE를 <strong>Stable Diffusion XL(SDXL)의 VAE로 교체</strong></li> <li><strong>VAE 교체 후 빠른 적응을 위해 2K Training Steps 만에 수렴하도록 학습 전략 적용</strong>.</li> <li>새로운 VAE 적용 후에도 <strong>기존 모델의 가중치를 재사용하여 빠르게 학습 가능</strong>.</li> </ul> <figure> <picture> <img src="/files/2025-02-09-pixart-sigma/image%205.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="2-해상도-업그레이드-resolution-upscaling"><strong>(2) 해상도 업그레이드 (Resolution Upscaling)</strong></h3> <ul> <li> <p>256px → 512px → 1024px → 4K로 점진적으로 해상도를 증가시키며 학습.</p> </li> <li><strong>PE Interpolation</strong>(위치 임베딩 보간법)을 적용하여, 기존 해상도의 가중치를 새 해상도에서도 자연스럽게 사용 가능하도록 조정. <ul> <li>보간법 (Interpolation)은 <strong>알려진 값을 기반으로 값을 계산하는 프로세스</strong></li> <li>Transformer 기반 모델(예: DiT, ViT 등)은 <strong>입력 이미지의 각 위치 정보를 표현하기 위해 위치 임베딩을 사용</strong>.</li> <li>모델이 256×256에서 학습되었다면, <strong>256×256 해상도에 최적화된 위치 임베딩을 학습함</strong>.</li> <li>하지만 해상도를 1024×1024로 증가시키면, <strong>기존 256×256 위치 임베딩과 구조가 달라져 모델 성능이 급격히 저하됨</strong>.</li> <li>기존 위치 임베딩을 1024×1024 크기로 보간(interpolation)</li> <li>즉, 256개의 값을 1024개로 확장하는 과정에서 자연스럽게 매끄러운 값으로 변환됨.</li> <li>이를 통해 새로운 해상도에서도 기존 모델의 공간 정보가 유지됨.</li> </ul> </li> <li><strong>단 1000 Training Steps만으로도 해상도 증가에 적응 가능</strong>.</li> </ul> <figure> <picture> <img src="/files/2025-02-09-pixart-sigma/image%206.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h3 id="3-kv-token-compression-도입-연산-최적화"><strong>(3) KV Token Compression 도입 (연산 최적화)</strong></h3> <ul> <li>PixArt-Σ 모델은 KV Token Compression을 적용했음</li> <li>하지만 <strong>기존 모델과 구조가 달라서 성능 저하 위험이 있음</strong>.</li> <li>PixArt-Σ에서는 <strong>기존 모델에서 자연스럽게 적응하도록 “Conv Avg Init.” 전략 적용</strong>.</li> </ul> <h3 id="평균-연산averaging-기반-초기화"><strong>평균 연산(Averaging) 기반 초기화</strong></h3> <ul> <li><strong>Conv Avg Init은 가중치 값을 <code class="language-plaintext highlighter-rouge">1/R²</code>로 설정하여, 기존 정보를 최대한 유지하면서 부드럽게 전환함</strong>.</li> <li> <p><strong>즉, 단순히 압축하는 것이 아니라 기존 공간 정보를 최대한 보존하는 방식</strong>.</p> </li> <li>초기에는 압축 없이 학습 후, <strong>학습이 안정화되면 KV Compression을 적용하여 연산량 감소</strong>.</li> <li><strong>4K 이미지 생성 시 연산량 34% 절감</strong>.</li> </ul> <p><strong>결과적으로, 기존 PixArt-α 대비 적은 연산량과 빠른 학습으로 4K 이미지 생성이 가능해짐.</strong></p> <figure> <picture> <img src="/files/2025-02-09-pixart-sigma/image%207.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h1 id="4-experiment">4. Experiment</h1> <h2 id="41-implementation-details-구현-세부사항">4.1 Implementation Details (구현 세부사항)</h2> <h3 id="1-모델-구성"><strong>1. 모델 구성</strong></h3> <p><strong>텍스트 인코더</strong></p> <ul> <li><strong>Flan-T5-XXL 사용</strong> (Imagen 및 PixArt-α와 동일)</li> <li>기존 모델에서 <strong>120개 토큰</strong>을 사용하던 것을 <strong>300개 토큰까지 확장</strong>하여 더 정밀한 텍스트-이미지 정렬 가능.</li> </ul> <p><strong>VAE (Variational Autoencoder) 적용</strong></p> <ul> <li><strong>Stable Diffusion XL(SDXL)의 VAE 사용</strong></li> <li><strong>더 높은 품질의 이미지 디코딩 가능</strong> → 세밀한 디테일 보존</li> </ul> <p><strong>기반 모델</strong></p> <ul> <li><strong>PixArt-α를 베이스 모델로 사용</strong></li> <li><strong>256px 사전 학습된 체크포인트를 활용하여 4K까지 확장</strong></li> </ul> <p><strong>KV Token Compression 적용</strong></p> <ul> <li><strong>연산량 34% 절감</strong></li> <li><strong>초고해상도(4K) 이미지 생성을 가능하게 함</strong></li> </ul> <hr/> <h3 id="2-학습-환경-및-하드웨어"><strong>2. 학습 환경 및 하드웨어</strong></h3> <p><strong>훈련 GPU 환경</strong></p> <ul> <li><strong>1K 모델 학습: 32 V100 GPUs 사용</strong></li> <li><strong>2K &amp; 4K 모델 학습: 16 A100 GPUs 사용</strong></li> </ul> <p><strong>최적화 알고리즘</strong></p> <ul> <li><strong>CAME Optimizer 사용</strong> (AdamW 대신)</li> <li><strong>학습률: 2e-5 (고정 Learning Rate 사용)</strong></li> <li><strong>Weight Decay: 0</strong></li> </ul> <p><strong>Position Embedding Interpolation (PE Interp.) 적용</strong></p> <ul> <li>낮은 해상도에서 학습된 모델을 고해상도로 변환할 때 <strong>위치 임베딩을 보간(interpolation)하여 적용</strong>.</li> <li>이를 통해 <strong>고해상도로 확장 시 성능 저하 없이 빠르게 적응 가능</strong>.</li> </ul> <hr/> <h3 id="3-학습-데이터-및-훈련-과정"><strong>3. 학습 데이터 및 훈련 과정</strong></h3> <p><strong>훈련 데이터셋</strong></p> <ul> <li><strong>총 33M(3,300만 개)의 고해상도 이미지 사용</strong></li> <li><strong>1K 해상도 이상의 데이터만 포함</strong></li> <li><strong>4K 해상도 이미지 2.3M(230만 개) 포함</strong></li> <li><strong>Aesthetic Scoring Model(AES) 적용하여 고품질 이미지 선별</strong></li> </ul> <p><strong>훈련 과정</strong></p> <ul> <li><strong>256px → 512px → 1024px → 4K 해상도로 점진적 업스케일링 적용</strong></li> <li><strong>VAE 교체 후 2K Training Steps 내 빠르게 적응</strong></li> <li><strong>PE Interpolation을 적용하여 고해상도에서 추가 학습 비용 절감</strong></li> </ul> <p><strong>학습 비용 절감</strong></p> <ul> <li>기존 PixArt-α 대비 <strong>훈련 비용 9%만 사용하여 1K 생성 가능</strong></li> <li><strong>KV Compression과 Weak-to-Strong Training을 결합하여 GPU 비용 절감</strong></li> </ul> <h2 id="42-실험-결과">4.2 실험 결과</h2> <h2 id="1-이미지-품질-비교-qualitative-evaluation"><strong>1. 이미지 품질 비교 (Qualitative Evaluation)</strong></h2> <p>PixArt-Σ는 <strong>포토리얼리즘(Photorealism), 디테일 수준, 스타일 다양성 측면에서 이전 모델보다 개선됨</strong>.</p> <p>아래와 같은 모델들과 비교됨:</p> <figure> <picture> <img src="/files/2025-02-09-pixart-sigma/image%208.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <h2 id="pixart-α-vs-pixart-σ">PixArt-α vs PixArt-Σ</h2> <table> <thead> <tr> <th>항목</th> <th>PixArt-α (기존)</th> <th>PixArt-Σ (개선)</th> </tr> </thead> <tbody> <tr> <td><strong>최대 해상도</strong></td> <td>1K (1024×1024)</td> <td><strong>4K (3840×2160) 지원</strong></td> </tr> <tr> <td><strong>연산량 최적화</strong></td> <td>없음</td> <td><strong>KV Token Compression 적용 (연산량 34% 감소)</strong></td> </tr> <tr> <td><strong>VAE 모델</strong></td> <td>기본 VAE</td> <td><strong>SDXL VAE로 변경 (고품질 이미지 생성 가능)</strong></td> </tr> <tr> <td><strong>학습 전략</strong></td> <td>일반 학습</td> <td><strong>Weak-to-Strong Training (기존 모델 활용하여 빠르게 학습)</strong></td> </tr> <tr> <td><strong>텍스트 길이</strong></td> <td>120 토큰</td> <td><strong>300 토큰으로 확장 (더 정밀한 텍스트-이미지 정렬 가능)</strong></td> </tr> <tr> <td><strong>훈련 비용</strong></td> <td>높음</td> <td><strong>기존 대비 GPU 비용 9%로 절감</strong></td> </tr> </tbody> </table> <h3 id="pixart-σ-vs-mobilediffusion-비교표"><strong>PixArt-Σ vs. MobileDiffusion 비교표</strong></h3> <table> <thead> <tr> <th>항목</th> <th><strong>PixArt-Σ</strong></th> <th><strong>MobileDiffusion</strong></th> <th>비교</th> </tr> </thead> <tbody> <tr> <td><strong>목표</strong></td> <td><strong>4K 초고해상도 이미지 생성</strong></td> <td><strong>모바일에서 실시간 생성 가능하도록 최적화</strong></td> <td>PixArt-Σ는 초고해상도 생성, MobileDiffusion은 On-Device 최적화</td> </tr> <tr> <td><strong>모델 구조</strong></td> <td><strong>Diffusion Transformer (DiT)</strong> 기반</td> <td><strong>Latent Diffusion + Optimized UNet</strong></td> <td>PixArt-Σ는 Transformer 기반, MobileDiffusion은 UNet 기반</td> </tr> <tr> <td><strong>텍스트 인코더</strong></td> <td><strong>Flan-T5-XXL (300 토큰까지 가능)</strong></td> <td><strong>CLIP-ViT/L14 (텍스트-이미지 효율성 극대화)</strong></td> <td>PixArt-Σ가 더 긴 텍스트 입력 가능, MobileDiffusion은 가벼움</td> </tr> <tr> <td><strong>이미지 해상도</strong></td> <td><strong>4K (3840×2160) 직접 생성 가능</strong></td> <td><strong>512×512 (On-Device에서 빠르게 생성)</strong></td> <td>PixArt-Σ는 초고해상도, MobileDiffusion은 저해상도 최적화</td> </tr> <tr> <td><strong>KV Token Compression</strong></td> <td><strong>Self-Attention 연산량 34% 절감 (R=2, R=4 적용)</strong></td> <td>❌ 사용하지 않음</td> <td>PixArt-Σ는 4K 최적화, MobileDiffusion은 경량 모델이라 필요 없음</td> </tr> <tr> <td><strong>모델 크기</strong></td> <td><strong>0.6B 파라미터 (SDXL: 2.6B 대비 작음)</strong></td> <td><strong>386M (SD-1.5 대비 55% 축소)</strong></td> <td>MobileDiffusion이 더 작음</td> </tr> <tr> <td><strong>VAE (Autoencoder)</strong></td> <td><strong>SDXL VAE 사용 (고품질 이미지 복원 가능)</strong></td> <td><strong>경량화된 VAE 적용 (512px에서 최적화됨)</strong></td> <td>PixArt-Σ는 품질 우선, MobileDiffusion은 속도 우선</td> </tr> <tr> <td><strong>해상도 업스케일링 기법</strong></td> <td><strong>PE Interpolation (기존 모델을 고해상도로 자연스럽게 변환)</strong></td> <td><strong>512px 고정 (Upscaling 없음)</strong></td> <td>PixArt-Σ는 해상도 확장 가능, MobileDiffusion은 저해상도 고정</td> </tr> <tr> <td><strong>연산 최적화</strong></td> <td><strong>Weak-to-Strong Training (기존 모델 재사용으로 학습 비용 절감)</strong></td> <td><strong>Transformer 블록 제거 + Convolution 기반 최적화</strong></td> <td>PixArt-Σ는 기존 모델 활용, MobileDiffusion은 경량화 모델</td> </tr> <tr> <td><strong>On-Device 실행 가능 여부</strong></td> <td>❌ 불가능 (고성능 GPU 필요)</td> <td>가능 (iPhone 15 Pro에서 0.2초 생성)</td> <td>MobileDiffusion이 훨씬 가벼움</td> </tr> <tr> <td><strong>학습 데이터 크기</strong></td> <td><strong>33M (4K 데이터 포함, SD v1.5의 1.65%)</strong></td> <td><strong>150M (모바일 최적화된 데이터)</strong></td> <td>MobileDiffusion이 더 큰 데이터셋 사용</td> </tr> <tr> <td><strong>이미지 품질 평가 (FID Score)</strong></td> <td><strong>8.23 (PixArt-α 대비 개선됨)</strong></td> <td><strong>11.67 (1-step) / 8.65 (50-step DDIM)</strong></td> <td>PixArt-Σ가 품질 우수, MobileDiffusion은 속도 최적화</td> </tr> <tr> <td><strong>텍스트-이미지 정렬 (CLIP Score)</strong></td> <td><strong>0.2797 (PixArt-α 대비 향상됨)</strong></td> <td><strong>0.320 (1-step) / 0.325 (50-step DDIM)</strong></td> <td>MobileDiffusion이 더 나은 정렬 성능</td> </tr> <tr> <td><strong>생성 속도</strong></td> <td>❌ 느림 (4K 생성에 고사양 GPU 필요)</td> <td>0.2초 (iPhone 15 Pro에서 실시간 생성)</td> <td>MobileDiffusion이 훨씬 빠름</td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="Paper"/><category term="AI"/><summary type="html"><![CDATA[Authors: Junsong Chen, Chongjian Ge, Enze Xie, Yue Wu, Lewei Yao, Xiaozhe Ren, Zhongdao Wang, Ping Luo, Huchuan Lu, Zhenguo Li Venue &amp; Year: 24, ArXiv 날짜: 2025년 2월 9일]]></summary></entry></feed>