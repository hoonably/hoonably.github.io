<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="UF9aPIHL0gyy9XNMhsgSZizZ_Ni9ciW6GIzLr4ZYIZc"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> TSP Algorithm | hoonably </title> <meta name="author" content="Jeonghoon Park"> <meta name="description" content="Implements and evaluates classical and novel algorithms for the Traveling Salesman Problem, with a focus on flow-based cycle covers and local refinements."> <meta name="keywords" content="UNIST, computer science, undergraduate, on-device AI, optimization, problem solving"> <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"> <meta http-equiv="Pragma" content="no-cache"> <meta http-equiv="Expires" content="0"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.css" integrity="sha256-uRX+PiRTR4ysKFRCykT8HLuRCub26LgXJZym3Yeom1c=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pseudocode@2.4.1/build/pseudocode.min.css" integrity="sha256-VwMV//xgBPDyRFVSOshhRhzJRDyBmIACniLPpeXNUdc=" crossorigin="anonymous"> <link rel="shortcut icon" href="/assets/img/profile/profile.webp?b5bec9d555338d1029578e54703400f7"> <link rel="stylesheet" href="/assets/css/pretendard-subset.css"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://hoonably.github.io/projects/traveling-salesman/"> <script src="/assets/js/theme.js?c06f90403cefcf6ac822b3d318259fcc"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-dark.css?7f7b80282ea53f5dd6b976ff3d9857f9" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> hoonably </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="pagein"> <div class="post"> <header class="post-header"> <h1 class="post-title">TSP Algorithm</h1> <p class="post-description">Implements and evaluates classical and novel algorithms for the Traveling Salesman Problem, with a focus on flow-based cycle covers and local refinements.</p> </header> <article> <div class="repo p-2 text-center"> <a href="https://github.com/hoonably/traveling-salesman" rel="external nofollow noopener" target="_blank"> <img class="only-light w-100" alt="hoonably/traveling-salesman" src="https://github-readme-stats.vercel.app/api/pin/?username=hoonably&amp;repo=traveling-salesman&amp;theme=default&amp;locale=en&amp;show_owner=false&amp;description_lines_count=2"> <img class="only-dark w-100" alt="hoonably/traveling-salesman" src="https://github-readme-stats.vercel.app/api/pin/?username=hoonably&amp;repo=traveling-salesman&amp;theme=dark&amp;locale=en&amp;show_owner=false&amp;description_lines_count=2"> </a> </div> <blockquote class="block-tip"> <p><strong>ğŸ“„ PDF:</strong> <a href="https://hoonably.github.io/traveling-salesman/">Project PDF</a></p> </blockquote> <hr> <h3 id="introduction">INTRODUCTION</h3> <p>The Traveling Salesman Problem (TSP) is a well-known NP-hard problem in combinatorial optimization. It seeks the shortest tour that visits each city exactly once and returns to the origin, with applications ranging from logistics to circuit design.</p> <p>To address its computational intractability, a wide range of heuristics and approximation algorithms have been developed. The MST-based 2-approximation algorithm provides theoretical guarantees under the triangle inequality, while greedy and local search methods such as 2-opt offer strong empirical performance despite lacking worst-case bounds.</p> <p>In this project, we implement several classical algorithms including Held-Karp dynamic programming, MST-based approximation, greedy heuristics, and 2-opt refinement, as well as a novel flow-based heuristic. This method leverages minimum-cost maximum-flow (MCMF) to generate cycle covers, which are then refined by 2-opt. We also apply <em>k</em>-nearest-neighbor sparsification to improve scalability.</p> <p>Although our method is generally slower than classical heuristics, its combination with 2-opt yields comparable tour quality. Sparsification significantly reduces runtime, making the approach more practical for larger instances.</p> <hr> <h3 id="problem-statement">PROBLEM STATEMENT</h3> <p>The Traveling Salesman Problem (TSP) asks: given a set of <em>n</em> cities and pairwise costs <em>câ‚áµ¢â±¼â‚</em>, find the shortest possible tour that visits each city exactly once and returns to the starting point. Formally, for <strong>V = {vâ‚, vâ‚‚, â€¦, vâ‚™}</strong>, the objective is:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>min over Ï€ âˆˆ Sâ‚™ of ( c[Ï€(n)][Ï€(1)] + âˆ‘áµ¢â‚Œâ‚â¿â»Â¹ c[Ï€(i)][Ï€(i+1)] )
</code></pre></div></div> <p>where <em>Sâ‚™</em> is the set of all permutations of <em>n</em> elements.</p> <hr> <h4 id="computational-complexity">Computational Complexity</h4> <p>TSP is a classic <strong>NP-hard</strong> problem. The decision version is <strong>NP-complete</strong>, and the optimization version is <strong>NP-hard</strong> but not known to be in NP. Since the number of feasible tours grows factorially, exact algorithms quickly become infeasible as <em>n</em> increases.</p> <hr> <h4 id="approximation-motivation">Approximation Motivation</h4> <p>Due to the problemâ€™s intractability, various approximation algorithms have been proposed for the metric TSP. MST-based methods offer theoretical guarantees, while Greedy and 2-opt heuristics perform well in practice. Our method builds on these ideas by combining global flow structure with local refinement.</p> <hr> <h2 id="existing-algorithms">EXISTING ALGORITHMS</h2> <h3 id="held-karp-dynamic-programming">Held-Karp (Dynamic Programming)</h3> <p>The Held-Karp algorithm [Held &amp; Karp, 1962] computes the exact TSP solution via dynamic programming by storing the minimal cost <em>C(S, j)</em> of reaching city <em>j</em> through subset <em>S</em>. It avoids enumerating all <em>n!</em> permutations by using the recurrence:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C(S, j) = min over k âˆˆ S \ {j} of [ C(S \ {j}, k) + c_kj ]
</code></pre></div></div> <p>with base case:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C({1, j}, j) = c_1j
</code></pre></div></div> <p>Assuming city 1 is the start, the optimal tour cost is:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>min over j â‰  1 of [ C({1,...,n}, j) + c_j1 ]
</code></pre></div></div> <h4 id="pseudocode-held-karp-tsp">Pseudocode: Held-Karp-TSP</h4> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Held-Karp TSP}
\begin{algorithmic}
\FOR{$j := 2$ \TO $n$}
  \STATE $C[\{1,j\}][j] := c_{1j}$
\ENDFOR

\FOR{$s := 3$ \TO $n$}
  \FOR{each $S$ of size $s$ containing $1$}
    \FOR{$j \in S \setminus \{1\}$}
      \STATE $C[S][j] := \min_k \left(C[S \setminus \{j\}][k] + c_{kj}\right)$
    \ENDFOR
  \ENDFOR
\ENDFOR

\STATE Reconstruct tour $T$ from $C$
\RETURN $T$
\end{algorithmic}
\end{algorithm}

</code></pre> <h3 id="time-and-space-complexity">Time and Space Complexity</h3> <ul> <li> <strong>Time:</strong> ğ’ª(nÂ² Â· 2â¿)</li> <li> <strong>Space:</strong> ğ’ª(n Â· 2â¿)</li> </ul> <h3 id="advantages">Advantages</h3> <ul> <li>Provides the exact optimal solution for small instances.</li> </ul> <h3 id="limitations">Limitations</h3> <ul> <li>Exponential time and space complexity makes it infeasible beyond <em>n &gt; 30</em> </li> <li>Generally superseded by efficient solvers like <strong>Concorde</strong>.</li> </ul> <hr> <h3 id="mst-based-2-approximation-algorithm">MST-based 2-Approximation Algorithm</h3> <p>This classical algorithm [CLRS 3rd ed.] constructs a tour with cost at most twice the optimal, assuming the triangle inequality. It builds a <strong>Minimum Spanning Tree (MST)</strong>, performs a <strong>preorder traversal</strong> to list the nodes, and <strong>shortcuts</strong> repeated visits to yield a Hamiltonian tour.</p> <h3 id="pseudocode-mst-based-tsp">Pseudocode: MST-Based-TSP</h3> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{MST-Based TSP}
\begin{algorithmic}
\STATE choose start node r
\STATE compute MST T rooted at r (e.g., Primâ€™s algorithm)
\STATE perform preorder traversal on T to obtain path P
\STATE shortcut repeated nodes in P to construct Hamiltonian tour H
\RETURN tour H
\end{algorithmic}
\end{algorithm}
</code></pre> <h3 id="time-and-space-complexity-1">Time and Space Complexity</h3> <ul> <li> <strong>Time:</strong> ğ’ª(nÂ²)</li> <li> <strong>Space:</strong> ğ’ª(n)</li> </ul> <h3 id="approximation-guarantee">Approximation Guarantee</h3> <p>Let <strong>H*</strong> be the optimal tour and <strong>T</strong> the MST. Then:</p> <ul> <li> <p>Removing one edge from <strong>H*</strong> yields a spanning tree â‡’ â†’â€ƒ<strong>c(T) â‰¤ c(H*)</strong></p> </li> <li> <p>A DFS traversal of T visits each edge twice â‡’ â†’â€ƒ<strong>c(W) = 2 Â· c(T) â‰¤ 2 Â· c(H*)</strong></p> </li> <li> <p>Using the triangle inequality, shortcutting repeated nodes gives a tour <strong>H</strong> such that:</p> </li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c(H) â‰¤ c(W) â‰¤ 2 Â· c(H*)
</code></pre></div></div> <p>Thus, the output tour is guaranteed to be at most twice the cost of the optimal solution. This algorithm is a formal <strong>2-approximation</strong> for the <strong>metric TSP</strong>.</p> <h3 id="advantages-1">Advantages</h3> <ul> <li>Simple and easy to implement</li> <li>Offers a provable 2-approximation guarantee under the triangle inequality</li> </ul> <h3 id="limitations-1">Limitations</h3> <ul> <li>In the worst case, it may return a tour nearly <strong>twice as long as optimal</strong> </li> <li>The approximation guarantee fails if the <strong>triangle inequality does not hold</strong> </li> </ul> <hr> <h2 id="greedy-nearest-neighbor-heuristic">Greedy Nearest-Neighbor Heuristic</h2> <p>This heuristic, originally introduced by Flood [1956], builds a tour by repeatedly visiting the closest unvisited city. Starting from an initial node, it adds the nearest neighbor to the tour until all cities are visited, then returns to the starting city to complete the tour.</p> <h3 id="pseudocode-greedy-tsp">Pseudocode: Greedy-TSP</h3> <pre><code class="language-pseudocode">\begin{algorithm}
\caption{Greedy TSP}
\begin{algorithmic}
\STATE tour := [v0], visited := \{v0\}
\WHILE{some cities remain unvisited}
  \STATE let u be the nearest unvisited neighbor of last node in tour
  \STATE append u to tour
  \STATE mark u as visited
\ENDWHILE
\STATE append v0 to close the tour
\RETURN tour
\end{algorithmic}
\end{algorithm}
</code></pre> <h3 id="time-and-space-complexity-2">Time and Space Complexity</h3> <ul> <li> <strong>Time:</strong> ğ’ª(nÂ²)</li> <li> <strong>Space:</strong> ğ’ª(n)</li> </ul> <h3 id="approximation-behavior">Approximation Behavior</h3> <p>Despite its simplicity, Greedy offers <strong>no worst-case or approximation guarantee</strong>, and may produce tours arbitrarily worse than optimal. However:</p> <ul> <li>It performs well on <strong>Euclidean</strong> or <strong>spatially clustered</strong> data</li> <li>Often outperforms MST-based tours <strong>in practice</strong> </li> <li>Recent work by <strong>Frieze and Pegden (2024)</strong> shows that its <strong>average-case performance</strong> is significantly better than worst-case expectations</li> </ul> <h3 id="advantages-2">Advantages</h3> <ul> <li>Extremely fast</li> <li>Easy to implement</li> <li>Performs well on spatial or metric inputs</li> </ul> <h3 id="limitations-2">Limitations</h3> <ul> <li>No global planning â†’ can perform poorly in adversarial/non-metric cases</li> </ul> <hr> <h2 id="2-opt-local-optimization">2-Opt Local Optimization</h2> <p>2-opt [Croes, 1958] improves a tour by iteratively swapping two edges to reduce total cost. It is commonly used for <strong>post-processing heuristic tours</strong>.</p> <h3 id="pseudocode-two-opt">Pseudocode: Two-Opt</h3> <pre><code class="language-pseudocode">while any 2-swap improves cost:
    check all pairs of non-adjacent edges
    if a swap improves the tour:
        apply the swap
return improved tour
</code></pre> <h3 id="time-and-space-complexity-3">Time and Space Complexity</h3> <ul> <li> <p><strong>Time:</strong> ğ’ª(k Â· nÂ²), where</p> <ul> <li> <em>k = O(1)</em> for structured inputs</li> <li> <em>k = O(n)</em> for random inputs</li> </ul> </li> <li> <p><strong>Space:</strong> ğ’ª(n)</p> </li> </ul> <p>So, total time ranges from <strong>ğ’ª(nÂ²)</strong> to <strong>ğ’ª(nÂ³)</strong> depending on input structure.</p> <h3 id="advantages-3">Advantages</h3> <ul> <li>Highly effective local optimization</li> <li>Consistently improves tour quality</li> </ul> <h3 id="limitations-3">Limitations</h3> <ul> <li>Can converge to <strong>local optima</strong> </li> <li>May be <strong>slow</strong> if applied to poor initial tours</li> </ul> <h3 id="table-comparison-between-base-and-2opt-variants-across-datasets">Table: Comparison between base and +2opt variants across datasets</h3> <figure> <picture> <img src="/assets/img/projects/tsp/table.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <table> <thead> <tr> <th>Dataset</th> <th>Opt</th> <th>Algorithm</th> <th>Base Length</th> <th>Base Approx</th> <th>Base Time (s)</th> <th>+2opt Length</th> <th>+2opt Approx</th> <th>+2opt Time (s)</th> <th>2opt Iters</th> </tr> </thead> <tbody> <tr> <td><strong>a280</strong></td> <td>2579</td> <td>Random</td> <td>33736</td> <td>13.0741</td> <td>-</td> <td>2774</td> <td>1.0756</td> <td>0.0229</td> <td>1368</td> </tr> <tr> <td>Â </td> <td>Â </td> <td>Greedy</td> <td>3157</td> <td><strong>1.2244</strong></td> <td>0.0001</td> <td>2767</td> <td>1.0729</td> <td>0.0030</td> <td>57</td> </tr> <tr> <td>Â </td> <td>Â </td> <td>MST</td> <td>3492</td> <td>1.3540</td> <td>0.0003</td> <td>2908</td> <td>1.1276</td> <td>0.0045</td> <td>80</td> </tr> <tr> <td>Â </td> <td>Â </td> <td><em>Flow</em></td> <td>3417</td> <td>1.3251</td> <td>0.0162</td> <td>2705</td> <td>1.0489</td> <td>0.0190</td> <td>66</td> </tr> <tr> <td>Â </td> <td>Â </td> <td><em>Flow_kNN</em></td> <td>3348</td> <td>1.2979</td> <td>0.0067</td> <td>2696</td> <td><strong>1.0453</strong></td> <td>0.0118</td> <td>82</td> </tr> <tr> <td><strong>xql662</strong></td> <td>2513</td> <td>Random</td> <td>53168</td> <td>21.1507</td> <td>-</td> <td>2762</td> <td>1.0989</td> <td>0.2770</td> <td>3945</td> </tr> <tr> <td>Â </td> <td>Â </td> <td>Greedy</td> <td>3124</td> <td><strong>1.2430</strong></td> <td>0.0008</td> <td>2693</td> <td><strong>1.0716</strong></td> <td>0.0320</td> <td>116</td> </tr> <tr> <td>Â </td> <td>Â </td> <td>MST</td> <td>3593</td> <td>1.4299</td> <td>0.0012</td> <td>2763</td> <td>1.0996</td> <td>0.0393</td> <td>237</td> </tr> <tr> <td>Â </td> <td>Â </td> <td><em>Flow</em></td> <td>3862</td> <td>1.5373</td> <td>0.0641</td> <td>2719</td> <td>1.0819</td> <td>0.0931</td> <td>267</td> </tr> <tr> <td>Â </td> <td>Â </td> <td><em>Flow_kNN</em></td> <td>3931</td> <td>1.5640</td> <td>0.0341</td> <td>2737</td> <td>1.0893</td> <td>0.0700</td> <td>301</td> </tr> <tr> <td><strong>kz9976</strong></td> <td>1061882</td> <td>Random</td> <td>133724845</td> <td>125.9204</td> <td>-</td> <td>1154441</td> <td>1.0868</td> <td>3582.8043</td> <td>119612</td> </tr> <tr> <td>Â </td> <td>Â </td> <td>Greedy</td> <td>1358249</td> <td><strong>1.2790</strong></td> <td>0.0616</td> <td>1141502</td> <td>1.0752</td> <td>146.7960</td> <td>3340</td> </tr> <tr> <td>Â </td> <td>Â </td> <td>MST</td> <td>1456572</td> <td>1.3719</td> <td>0.1276</td> <td>1162397</td> <td>1.0947</td> <td>171.8004</td> <td>4638</td> </tr> <tr> <td>Â </td> <td>Â </td> <td><em>Flow</em></td> <td>1707487</td> <td>1.6081</td> <td>210.4066</td> <td>1138579</td> <td><strong>1.0731</strong></td> <td>537.8807</td> <td>5619</td> </tr> <tr> <td>Â </td> <td>Â </td> <td><em>Flow_kNN</em></td> <td>1719092</td> <td>1.6193</td> <td>21.7863</td> <td>1146693</td> <td>1.0799</td> <td>318.3891</td> <td>6231</td> </tr> </tbody> </table> <hr> <h2 id="proposed-algorithm">PROPOSED ALGORITHM</h2> <p>Existing heuristics like Greedy and MST tend to focus on local optimization and may miss global structure. We adopt <strong>Minimum-Cost Maximum-Flow (MCMF)</strong> to better capture global cost patterns by generating a one-to-one matching across the entire set of cities. To compensate for the potential loss of local structure, we enhance the solution with <strong>Greedy-like subtour merging</strong> and <strong>2-opt refinement</strong>.</p> <hr> <h3 id="flow-based-cycle-cover-via-mcmf">Flow-based Cycle Cover via MCMF</h3> <p>We model the TSP as a <strong>cycle cover problem</strong>. The idea is to:</p> <ol> <li>Construct a bipartite flow graph with two copies of the city set.</li> <li>Apply MCMF to find a <strong>minimum-cost one-to-one assignment</strong>.</li> <li>Extract disjoint subtours (cycles).</li> <li>Iteratively merge cycles using the <strong>closest-pair heuristic</strong>.</li> </ol> <h4 id="pseudocode-flow-cycle-cover-tsp">Pseudocode: Flow-Cycle-Cover-TSP</h4> <pre><code class="language-pseudocode">Construct bipartite graph with source s, sink t, and city sets L and R
Connect s â†’ Láµ¢ and Râ±¼ â†’ t with capacity 1 and cost 0
Connect Láµ¢ â†’ Râ±¼ with capacity 1 and cost cáµ¢â±¼ for all i â‰  j
Run MCMF from s to t to obtain flow-based matching
Extract subtours from flow result
while more than one subtour remains:
    merge the two closest subtours
return final merged tour T
</code></pre> <h4 id="time-and-space-complexity-4">Time and Space Complexity</h4> <p>Using SPFA for shortest paths:</p> <ul> <li> <strong>Time:</strong> ğ’ª(nÂ³)</li> <li> <strong>Space:</strong> ğ’ª(nÂ²)</li> </ul> <hr> <h3 id="knn-sparsification-for-scalability">kNN Sparsification for Scalability</h3> <p>To improve efficiency, we retain only the <strong>k-nearest neighbors per node</strong> when constructing the bipartite graph. This sparsification:</p> <ul> <li>Reduces edge count</li> <li>Preserves local structure</li> <li>Retains most of MCMFâ€™s matching quality</li> </ul> <h4 id="time-and-space-complexity-5">Time and Space Complexity</h4> <ul> <li> <strong>Time:</strong> ğ’ª(knÂ²)</li> <li> <strong>Space:</strong> ğ’ª(kn)</li> <li>In practice: <strong>k = 20</strong> </li> </ul> <hr> <h3 id="refinement-with-2-opt">Refinement with 2-opt</h3> <p>After merging cycles from MCMF, the resulting tour may contain:</p> <ul> <li>Long edges</li> <li>Suboptimal transitions</li> <li>Edge crossings</li> </ul> <p>To refine this, we apply <strong>2-opt</strong>, which:</p> <ul> <li>Eliminates crossings</li> <li>Replaces long edges</li> <li>Improves tour quality locally</li> </ul> <hr> <h3 id="summary">Summary</h3> <p>By combining:</p> <ul> <li> <strong>Global optimization</strong> via MCMF</li> <li> <strong>Graph sparsification</strong> with kNN</li> <li> <strong>Local refinement</strong> using 2-opt</li> </ul> <p>we achieve a hybrid algorithm that balances solution quality and computational cost.</p> <hr> <h2 id="experiments">EXPERIMENTS</h2> <h3 id="experimental-setup">Experimental Setup</h3> <p>All experiments were conducted on a <strong>MacMini (Apple M4, 16GB RAM)</strong>. Code was compiled using <code class="language-plaintext highlighter-rouge">clang++</code> with flags <code class="language-plaintext highlighter-rouge">-std=c++17</code> and <code class="language-plaintext highlighter-rouge">-O2</code>. Five datasets using the <strong>EUC_2D</strong> metric were tested:</p> <ul> <li> <strong>weird20.tsp</strong> (20 cities)</li> <li> <strong>a280.tsp</strong> (280 cities) <a href="http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/" rel="external nofollow noopener" target="_blank">Source</a> </li> <li> <strong>xql662.tsp</strong> (662 cities) <a href="https://www.math.uwaterloo.ca/tsp/vlsi/index.html" rel="external nofollow noopener" target="_blank">Source</a> </li> <li> <strong>kz9976.tsp</strong> (9,976 cities) <a href="https://www.math.uwaterloo.ca/tsp/world/countries.html" rel="external nofollow noopener" target="_blank">Source</a> </li> <li> <strong>mona_lisa100K.tsp</strong> (100,000 cities) <a href="https://www.math.uwaterloo.ca/tsp/data/ml/monalisa.html" rel="external nofollow noopener" target="_blank">Source</a> </li> </ul> <hr> <h3 id="runtime-comparison">Runtime Comparison</h3> <p>Runtime is primarily dictated by two components:</p> <ul> <li>The cost of constructing the initial tour</li> <li>The cost of refining it with 2-opt</li> </ul> <table> <thead> <tr> <th>Algorithm</th> <th>Notes</th> </tr> </thead> <tbody> <tr> <td><strong>Greedy</strong></td> <td>Fastest, runs in milliseconds thanks to nearest-neighbor logic</td> </tr> <tr> <td><strong>MST</strong></td> <td>Slightly slower than Greedy but remains efficient</td> </tr> <tr> <td><strong>Flow-based (Full)</strong></td> <td>Significantly slower; solving MCMF dominates runtime, especially for large instances</td> </tr> <tr> <td><strong>Flow-based (kNN)</strong></td> <td>Improved over Full Flow, but still slower than Greedy or MST</td> </tr> <tr> <td><strong>2-opt</strong></td> <td>Runtime depends heavily on initial structure; more iterations needed when starting from Flow-based subtours</td> </tr> </tbody> </table> <hr> <h3 id="solution-quality">Solution Quality</h3> <p><strong>Before 2-opt</strong></p> <ul> <li> <strong>Greedy</strong> outperforms other heuristics in raw tour quality</li> <li> <strong>MST</strong> has a formal 2-approximation guarantee but often yields longer tours due to tree detours</li> <li> <strong>Flow / Flow_kNN</strong> perform poorly initially due to short, fragmented subtours</li> </ul> <p><strong>After 2-opt</strong></p> <ul> <li> <strong>Greedy</strong> improves modestly â€” already starts near local optimum</li> <li> <strong>MST</strong> gains slight improvement, but some suboptimal edges remain</li> <li> <strong>Flow / Flow_kNN</strong> show the <strong>largest improvements</strong>, surpassing MST and approaching Greedyâ€™s final tour quality</li> <li>Their gains are attributed to low-quality initial solutions, which offer more opportunity for refinement</li> </ul> <hr> <h3 id="observations-on-mcmf-initialization">Observations on MCMF Initialization</h3> <ul> <li>MCMF often yields <strong>many short subtours</strong>, especially 2-cycles</li> <li>This disrupts the intended global matching behavior</li> <li>The algorithm relies heavily on <strong>2-opt to recover a valid tour</strong> </li> <li>This increases both the <strong>number of iterations</strong> and the <strong>total runtime</strong> </li> </ul> <p>In summary, Flow-based methods benefit most from post-processing but are computationally expensive. Greedy remains the best trade-off for performance vs. quality.</p> <hr> <h3 id="ablation-flow-based-cycle-cover-variants">Ablation: Flow-based Cycle Cover Variants</h3> <p>Table highlights how <strong>$k$NN sparsification</strong> significantly reduces the number of edges processed during the MCMF step, resulting in noticeable runtime improvements. In particular, <strong>Flow_kNN</strong> demonstrates superior scalability compared to the full Flow method, especially on large-scale datasets such as <code class="language-plaintext highlighter-rouge">kz9976</code> and <code class="language-plaintext highlighter-rouge">mona_lisa100K</code>.</p> <hr> <h4 id="visual-comparison-before-and-after-2-opt-refinement">Visual Comparison Before and After 2-opt Refinement</h4> <figure> <picture> <img src="/assets/img/projects/tsp/flow.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong>Figure:</strong> Effect of 2-opt on the Flow-based tour for <code class="language-plaintext highlighter-rouge">a280</code>.</p> <hr> <p>In the initial Flow-generated tour, many <strong>long cross-edges</strong> are present, resulting from the greedy subtour merging phase. The application of <strong>2-opt</strong> significantly improves this, by identifying and replacing suboptimal segments, leading to:</p> <ul> <li>More compact routing</li> <li>Fewer long edges</li> <li>Lower total cost</li> </ul> <p>This is clearly reflected in the post-2opt diagram, where the path appears more coherent and globally efficient.</p> <hr> <h3 id="final-observation">Final Observation</h3> <p>Both <strong>kNN sparsification</strong> and <strong>2-opt</strong> operate in $\mathcal{O}(n^2)$ time, and when used together, they produce:</p> <ul> <li>Near-optimal tours</li> <li>Significantly lower memory and runtime cost than full-flow matching</li> <li>High scalability to tens of thousands of cities</li> </ul> <p>We conclude that <strong>Flow_kNN + 2-opt</strong> is a <strong>practical and effective hybrid strategy</strong> that balances global planning with local refinement.</p> <hr> <h3 id="additional-results">Additional Results</h3> <p>To test performance at both ends of the scale, we evaluated a <strong>tiny instance</strong> (<code class="language-plaintext highlighter-rouge">weird20</code>) and a <strong>massive dataset</strong> (<code class="language-plaintext highlighter-rouge">mona_lisa100K</code>). Results are shown in Table~\ref{tab:extreme_cases}.</p> <hr> <h4 id="table-held-karp-and-large-scale-results">Table: Held-Karp and Large-scale Results</h4> <table> <thead> <tr> <th><strong>Dataset</strong></th> <th><strong>Algorithm</strong></th> <th><strong>Length</strong></th> <th><strong>Time (s)</strong></th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">weird20</code></td> <td>Held-Karp</td> <td>439</td> <td>43.25</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">mona_lisa100K</code></td> <td>Best-known</td> <td>5,757,191</td> <td>â€”</td> </tr> <tr> <td>Â </td> <td>Greedy</td> <td>6,846,598</td> <td>16.99</td> </tr> <tr> <td>Â </td> <td>MST</td> <td>8,394,831</td> <td>32.03</td> </tr> <tr> <td>Â </td> <td>Flow_kNN</td> <td>7,276,478</td> <td>35,205.36</td> </tr> </tbody> </table> <blockquote> <p><em>Best-known tour:</em> <a href="https://www.math.uwaterloo.ca/tsp/data/ml/tour/monalisa_5757191.tour" rel="external nofollow noopener" target="_blank">mona_lisa_5757191.tour</a></p> </blockquote> <hr> <h4 id="weird20-20-cities"> <code class="language-plaintext highlighter-rouge">weird20</code> (20 cities)</h4> <ul> <li>Held-Karp gives <strong>exact optimal</strong> tour in 43 seconds.</li> <li>It is <strong>feasible only for small instances</strong> due to $\mathcal{O}(n^2 2^n)$ complexity.</li> <li>Serves as a reference baseline for solution quality.</li> </ul> <h4 id="mona_lisa100k-100000-cities"> <code class="language-plaintext highlighter-rouge">mona_lisa100K</code> (100,000 cities)</h4> <ul> <li> <strong>Greedy</strong> yields decent quality with the <strong>fastest runtime (17s)</strong>.</li> <li> <strong>MST</strong> takes longer and produces a <strong>much worse tour</strong> due to detours.</li> <li> <strong>Flow_kNN</strong> offers <strong>better tour quality</strong> than MST, at a <strong>high computational cost</strong> (â‰ˆ 10 hours).</li> </ul> <hr> <h3 id="visual-comparison-flow_knn-vs-mst-tours">Visual Comparison: Flow_kNN vs MST Tours</h3> <figure> <picture> <img src="/assets/img/projects/tsp/mona_lisa.webp" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong>Figure:</strong> Comparison of Flow_kNN and MST tours on <code class="language-plaintext highlighter-rouge">mona_lisa100K</code>.</p> <h4 id="observations">Observations</h4> <ul> <li> <p><strong>Flow_kNN</strong>:</p> <ul> <li>A few long edges (due to early subtour merging)</li> <li>Mostly short, coherent connections</li> <li>Leads to <strong>lower total tour cost</strong> </li> </ul> </li> <li> <p><strong>MST</strong>:</p> <ul> <li>More uniform edge spacing</li> <li>Suffers from <strong>accumulated detours</strong>, especially in sparse regions</li> </ul> </li> </ul> <blockquote> <p>Interestingly, this <strong>reverses earlier trends</strong>â€”in smaller datasets, MST often outperforms Flow. But at large scale, <strong>global initialization (Flow)</strong> appears to become more valuable, suggesting strong potential for <strong>Flow-based strategies in high-dimensional TSPs</strong>.</p> </blockquote> <hr> <h3 id="conclusion">CONCLUSION</h3> <p><strong>Summary of Findings</strong> This project explored a variety of classical and heuristic algorithms for solving the symmetric Traveling Salesman Problem (TSP). These included:</p> <ul> <li> <strong>Held-Karp</strong> dynamic programming for exact solutions,</li> <li> <strong>MST-based 2-approximation</strong> with provable bounds,</li> <li> <strong>Greedy nearest-neighbor</strong> heuristic with strong empirical performance,</li> <li> <strong>2-opt</strong> local refinement for improving tour quality.</li> </ul> <p>In addition, we proposed a <strong>Flow-based Cycle Cover heuristic</strong>, which utilizes <strong>Minimum-Cost Maximum-Flow (MCMF)</strong> to capture global edge structure. We enhanced this approach using <strong>$k$-nearest-neighbor sparsification</strong> and post-processing with <strong>2-opt</strong>.</p> <hr> <p><strong>Performance Analysis</strong> Among classical methods, <strong>Greedy</strong> provided the best balance of speed and quality, often outperforming MST despite its lack of approximation guarantees. The <strong>Flow-based method</strong>, while theoretically appealing, suffered from <strong>fragmented subtours</strong> that led to poor initial tours. The majority of its improvements came from 2-opt post-refinement, not from MCMF directly. This suggests that <strong>Flow alone is insufficient</strong> unless integrated with additional structure-aware mechanisms.</p> <hr> <p><strong>Limitation and Future Work</strong> The key weakness of the Flow-based method is its tendency to create <strong>short, disjoint cycles</strong>, limiting its utility as a standalone solver.</p> <p>A natural extension is to apply <strong>MCMF recursively</strong>, where:</p> <ul> <li>Each subtour is treated as a <strong>supernode</strong>, and</li> <li>A new flow graph is constructed over these aggregates.</li> </ul> <p>However, this raises a new challenge:</p> <ul> <li>Defining meaningful and consistent <strong>inter-subtour distances</strong> is difficult.</li> <li>Simple metrics (e.g., shortest inter-node edge) often fail to capture structural context and can result in poor merges.</li> </ul> <p>Successfully addressing this would allow <strong>purely flow-based, globally coordinated tour construction</strong>, offering a new hybrid between combinatorial optimization and network flow methods for large-scale TSPs.</p> <hr> <h3 id="-thoughts">ğŸ’¬ Thoughts</h3> <p>The most fun part of this project was coming up with my own algorithm instead of just using an existing one. I used MCMF to get a global structure and layered 2-opt on top to improve the tour quality â€” it didnâ€™t feel like I was just solving a homework problem, it actually felt like I was solving <em>a problem</em>.</p> <p>I always knew TSP was NP-hard, but running an exact algorithm like Held-Karp myself really hit it home. Now I get why people obsess over polynomial time â€” with exponential time, just increasing the number of cities a bit makes the whole thing blow up. It made me realize why algorithm research actually matters.</p> <p>At first, I naÃ¯vely thought Held-Karp would run fine for something like 200 cities. I let it run, waitedâ€¦ and it never finished. Then I realized 2^200 is an insane number. I even asked GPT if my code had a bug, and it politely roasted me saying thereâ€™s no bug â€” itâ€™s just that even if you had all the computers in the universe, it still wouldnâ€™t finish. That was humbling.</p> <p>The most surprising part? Problems like Mona Lisa 100K are still being worked on. I thought these had all been solved ages ago, but people are still out there breaking records and trying new ideas. Itâ€™s wild and kind of inspiring that thereâ€™s still progress being made on such a classic problem.</p> <p>That said, I wasnâ€™t really happy with my final results. I ran into unexpected issues and had to force 2-opt in just to get something that worked. I didnâ€™t love that, but it was already too late to start over, so I just rolled with it. Still, the project felt different from typical assignments â€” I got to design something of my own and compare it head-to-head with existing algorithms. That part was really cool.</p> <hr> <h3 id="-ëŠë‚€-ì ">ğŸ’¬ ëŠë‚€ ì </h3> <p>ì´ë²ˆ í”„ë¡œì íŠ¸ì—ì„œ ì œì¼ ì¬ë°Œì—ˆë˜ ê±´, ê·¸ëƒ¥ ìˆëŠ” ì•Œê³ ë¦¬ì¦˜ì„ ì“°ëŠ” ê²Œ ì•„ë‹ˆë¼ ì§ì ‘ ì•„ì´ë””ì–´ ì§œì„œ êµ¬í˜„í•´ë´¤ë‹¤ëŠ” ê²ƒì´ë‹¤. MCMFë¡œ ì „ì²´ íë¦„ ì¡ê³ , ê·¸ ìœ„ì— 2-opt ë¶™ì—¬ì„œ íˆ¬ì–´ í’ˆì§ˆ ë†’ì´ëŠ” ë°©ì‹ìœ¼ë¡œ í•´ë´¤ëŠ”ë°, ë‹¨ìˆœíˆ ê³¼ì œ í‘¸ëŠ” ëŠë‚Œì´ ì•„ë‹ˆë¼ì„œ ì¬ë°Œì—ˆë‹¤.</p> <p>TSPê°€ <strong>NP-hard</strong>í•˜ë‹¤ëŠ” ê±´ ì•Œê³ ëŠ” ìˆì—ˆëŠ”ë°, Held-Karp ê°™ì€ ì •í™•í•œ ì•Œê³ ë¦¬ì¦˜ì„ ì§ì ‘ ëŒë ¤ë³´ë‹ˆê¹Œ ê¹œì§ ë†€ëë‹¤. ì™œê·¸ë ‡ê²Œ <strong>Polynomial Time</strong>ì— í™˜ì¥í•˜ëŠ”ì§€ ì•Œ ê²ƒ ê°™ë‹¤. ì§€ìˆ˜ì‹œê°„ì´ ë˜ë‹ˆê¹Œ ë„ì‹œ ìˆ˜ ì¡°ê¸ˆë§Œ ëŠ˜ì–´ë‚˜ë„ ê°ë‹¹ ì•ˆ ë˜ëŠ” ê±¸ ë³´ë©´ì„œ ì‹¤ì œë¡œ ì•Œê³ ë¦¬ì¦˜ì„ ì™œ ì—°êµ¬í•˜ëŠ”ì§€ ëŠë¼ê²Œ ë˜ì—ˆë‹¤.</p> <p>ì‚¬ì‹¤ ì²˜ìŒì— Held-Karpë„ 200ì§œë¦¬ëŠ” ëŒì•„ê°ˆì¤„ì•Œê³  ëŒë ¸ëŠ”ë° ì•ˆëë‚˜ê¸¸ë˜ ìƒê°í•´ë³´ë‹ˆê¹Œ, 2^200ì€ ì—„ì²­ë‚œ ìˆ«ìì˜€ë‹¤. ìƒê°ì—†ì´ ëŒë¦¬ê³  GPTí•œí…Œ ì½”ë“œ ì˜¤ë¥˜ìˆëƒê³  ë¬¼ì–´ë´¤ëŠ”ë°, ì˜¤ë¥˜ ì—†ê³ , <strong>2^200ì€ ìš°ì£¼ì— ìˆëŠ” ëª¨ë“  ì»´í“¨í„° ê°€ì ¸ì™€ì„œ ëŒë ¤ë„ ì•ˆëë‚œë‹¤ê³  ë‚˜í•œí…Œ ê¼½</strong>ì„ ì¤˜ì„œ ìª½íŒ”ë ¸ë‹¤.</p> <p>ì œì¼ ì¸ìƒ ê¹Šì—ˆë˜ ê±´, ëª¨ë‚˜ë¦¬ì 100Kì²˜ëŸ¼ ì—„ì²­ ì˜¤ë˜ëœ TSP ë¬¸ì œë“¤ë„ ì•„ì§ë„ ì‚¬ëŒë“¤ì´ ë” ì¢‹ì€ í•´ë‹µ ì°¾ìœ¼ë ¤ê³  ë…¸ë ¥í•˜ê³  ìˆë‹¤ëŠ” ê²ƒì´ë‹¤. ì´ë¯¸ ë‹¤ ì—°êµ¬ëì„ ì¤„ ì•Œì•˜ëŠ”ë°, ì—¬ì „íˆ ê¸°ë¡ì´ ê¹¨ì§€ê³  ìˆë‹¤ëŠ” ê²Œ ë†€ë¼ì› ê³ , ê³„ì† ëˆ„êµ°ê°€ëŠ” ë…¸ë ¥í•˜ëŠ”ê²Œ ë©‹ì¡Œë‹¤.</p> <p>ê·¼ë° ê²°ê³¼ê°€ ë„ˆë¬´ ë³„ë¡œì˜€ê³ , ìƒê° ì™¸ì˜ ë¬¸ì œê°€ ë°œìƒí•´ì„œ ì–µì§€ë¡œ 2-opt ë¼ì›Œì„œ ì¢€ ë§˜ì— ì•ˆë“¤ì—ˆë‹¤. í•˜ì§€ë§Œ ë„ì €íˆ ë‹¤ë¥¸ ë°©ë²•ì„ ìƒê°í•˜ê¸°ì—ëŠ” ëŠ¦ì–´ì„œ ê³„ì† í–ˆë˜ ê²ƒ ê°™ë‹¤. í‰ë²”í•œ ê³¼ì œ ëŠë‚Œì´ ì•„ë‹ˆë¼ ë‚˜ë§Œì˜ ì•Œê³ ë¦¬ì¦˜ì„ ë§Œë“¤ê³  ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ê³¼ ì„±ëŠ¥ë¹„êµë¥¼ í•´ë³´ëŠ”ê²Œ ìƒ‰ë‹¬ë¼ì„œ ì¬ë°Œì—ˆë‹¤.</p> </article> <br><br><br><br> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'hoonably/hoonably.github.io',
        'data-repo-id': 'R_kgDOPBaE1Q',
        'data-category': 'Comments',
        'data-category-id': 'DIC_kwDOPBaE1c4Cr9sR',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '0',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'ko',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> <br><br><br><br> </div> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> Â© Copyright 2025 Jeonghoon Park. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://cdn.jsdelivr.net/npm/bootstrap-table@1.22.4/dist/bootstrap-table.min.js" integrity="sha256-4rppopQE9POKfukn2kEvhJ9Um25Cf6+IDVkARD0xh78=" crossorigin="anonymous"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/pseudocode-setup.js?72ed28a041e322f764b0d9c59cf428b5"></script> <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/pseudocode@2.4.1/build/pseudocode.min.js" integrity="sha256-aVkDxqyzrB+ExUsOY9PdyelkDhn/DfrjWu08aVpqNlo=" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>